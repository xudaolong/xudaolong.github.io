{"posts":[{"title":"ios-核心开发手册读书笔记","text":"手势与触摸 触摸的信息: 触摸事件: 触摸事件生死:","link":"/2015/10/11/ios/ios-%E6%A0%B8%E5%BF%83%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Aspose-barcode-条码和二维码处理","text":"条码信息和贴士 123http://china.keyence.com/ss/products/auto_id/barcode_lecture/ 应用背景:公司需要将发票中的二维码和条码一同识别并于相关的订单绑定至数据库 初略的第一版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266package com.xudaolong.bean;import com.aspose.barcode.*;import com.aspose.barcoderecognition.BarCodeReadType;import com.aspose.barcoderecognition.BarCodeReader;import com.xudaolong.Utils.ImageCutterUtil;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.util.ArrayList;/** * 文 件 名: AsposeBarcode.java * 创 建 人: xudaolong * 创建日期: 16/7/12 14:24 * 邮 箱: xudaolong@vip.qq.com * 博 客: http://xudaolong.github.io/ * 修改时间： * 修改备注： */public class AsposeBarcode { private static final String TAG = &quot;AsposeBarcode&quot;; /** * 发票信息列表 */ private ArrayList&lt;BarcodeInfo&gt; list = new ArrayList(); public AsposeBarcode() { } /** * 存储扫描发票信息(二维码和二五码) */ class BarcodeInfo { private static final String TAG = &quot;BarcodeInfo&quot;; public BarcodeInfo() { } private String FileName; private String Interleaved2of5; private String QR; public void clear() { this.setFileName(&quot;&quot;); this.setInterleaved2of5(&quot;&quot;); this.setQR(&quot;&quot;); } public String getFileName() { return FileName; } public void setFileName(String fileName) { this.FileName = fileName; } public String getQR() { return QR; } public void setQR(String QR) { this.QR = QR; } public String getInterleaved2of5() { return Interleaved2of5; } public void setInterleaved2of5(String interleaved2of5) { Interleaved2of5 = interleaved2of5; } public void checkInfo(BarcodeInfo _info) { if (_info.getInterleaved2of5().equals(&quot;&quot;)) { System.out.println(_info.getFileName() + &quot;:: 不能获取 Interleaved2of5 条形码&quot;); } if (_info.getQR().equals(&quot;&quot;)) { System.out.println(_info.getQR() + &quot;:: 不能获取 QR 条形码 &quot;); } } @Override public String toString() { return &quot;BarcodeInfo{&quot; + &quot;FileName='&quot; + this.getFileName() + '\\'' + &quot;, Interleaved2of5='&quot; + this.getInterleaved2of5() + '\\'' + &quot;, QR='&quot; + this.getQR() + '\\'' + '}'; } } /** * 获取工具类 * * @return */ public BarCodeBuilder getInstance() { return new BarCodeBuilder(); } /** * 获取一个普通的QR图片 * * @return */ public BarCodeBuilder getPublicQR(String context, String targetPath) { // 初始化 BarCodeBuilder builder = this.getInstance(); builder.setCodeText(context); builder.setSymbologyType(Symbology.QR); // 设置编程模式 builder.setQREncodeMode(QREncodeMode.Auto); // 设置容错率 builder.setQRErrorLevel(QRErrorLevel.LevelH); // 隐藏文字 builder.setCodeLocation(CodeLocation.None); // 翻转 builder.setRotationAngleF(0); builder.setImageHeight(88); builder.setImageWidth(88); // 保存 builder.save(targetPath); cutQR(targetPath); return builder; } public void cutQR(String sourcePath) { try { File file = new File(sourcePath); BufferedImage image = ImageIO.read(file); // 起始坐标，剪切大小 int x = 14; int y = 25; int width = 62; int height = 62; // 参考图像大小 int clientWidth = 88; int clientHeight = 88; double destWidth = image.getWidth(); double destHeight = image.getHeight(); if (destWidth &lt; width || destHeight &lt; height) throw new Exception(&quot;源图大小小于截取图片大小!&quot;); double widthRatio = destWidth / clientWidth; double heightRatio = destHeight / clientHeight; //修改一下单位 x = Double.valueOf(x * widthRatio).intValue(); y = Double.valueOf(y * heightRatio).intValue(); width = Double.valueOf(width * widthRatio).intValue(); height = Double.valueOf(height * heightRatio).intValue(); System.out.println(&quot;裁剪大小 x:&quot; + x + &quot;,y:&quot; + y + &quot;,width:&quot; + width + &quot;,height:&quot; + height); //获取指定的名字// String formatName = getImageFormatName(file);// String pathSuffix = &quot;.&quot; + formatName;// String pathPrefix = getFilePrefixPath(file);// String targetPath = pathPrefix + System.currentTimeMillis() + pathSuffix; //最后一步进行裁剪到指定的名字 File destFile = new File(sourcePath); ImageCutterUtil.cutImage(file, destFile, x, y, width, height); } catch (Exception e) { e.printStackTrace(); } } /** * 读取QR * * @return */ public ArrayList&lt;BarcodeInfo&gt; ReaderImg(String dest) throws IOException { if (dest == null) { return null; } /** * 转成 BufferedImage 图像缓存区便于操作 */// BufferedImage bufImg = ImageIO.read(new FileInputStream(dest)); //创建指定的读取器 25码 和 QR 码 BarCodeReader reader = new BarCodeReader(dest, BarCodeReadType.QR | BarCodeReadType.Interleaved2of5); /** * MaxPerformance 1 Finds all the possible good and average quality barcodes. Uses only the fastest algorithms. Enabled by default. * MaxQuality 2 Finds all the possible barcodes with good or bad quality. Doesn't return potential barcodes. Uses different fast and slow algorithms. * MaxBarCodes 3 Extends MaxQuality. Finds even potential barcodes. Uses extra algorithms which may recognize incorrect barcodes, barcodes on complex background, noisy or damaged barcodes and etc. You may observe extra spurious barcodes. * ManualHints 4 User configures hints optionally. Allows you to adjust the balance between speed and quality manually. */ reader.setRecognitionMode(1); /** * 设定识别超时,有助于提高识别效率 */// reader.setTimeout(3500); //暂时存储 BarcodeInfo _info = new BarcodeInfo(); //重置 _info.clear(); try { while (reader.read()) { _info.setFileName(reader.getFileName()); if (reader.getReadTypeName().equals(&quot;Interleaved2of5&quot;)) { _info.setInterleaved2of5(reader.getCodeText()); } if (reader.getReadTypeName().equals(&quot;QR&quot;)) { _info.setQR(reader.getCodeText()); } } list.add(_info); reader.close(); } catch (Exception e) { e.printStackTrace(); } finally { _info.checkInfo(_info); } return list; }} 测试文件 123456789101112131415161718192021222324252627282930313233343536373839package com.xudaolong.QR;import com.xudaolong.Utils.Path;import com.xudaolong.bean.AsposeBarcode;import java.io.IOException;import java.util.ArrayList;/** * Created by xudaolong on 16/7/12. */public class TestQR { public static void main(String[] args) throws IOException { //指定相对的路径 String path = “/resources/src/com/xudaolong/second”; long startTime=System.nanoTime(); //获取开始时间 ArrayList&lt;String&gt; allFile = new Path().getAllFile(path); for (int i = 0; i &lt; allFile.size(); i++) { String _filename = allFile.get(i); System.out.println(new AsposeBarcode().ReaderImg(_filename)); } long endTime=System.nanoTime(); //获取结束时间 System.out.println(“程序运行时间： “+(endTime-startTime)+”ns”); System.out.println(allFile); }} 辅助类 Path::用于处理路径的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.xudaolong.Utils;import java.io.File;import java.util.ArrayList;/** * Created by xudaolong on 16/7/12. */public class Path { private static final String TAG = &quot;Path&quot;; public static final String CURRFILE = new String(System.getProperty(&quot;user.dir&quot;)); /** * 创建不存在的目录 * * @param c * @param dir * @return */ public File rebuildDir(Class c, File dir) { for (String s : c.getName().split(&quot;\\\\.&quot;)) { dir = new File(dir, s); if (dir.isDirectory() == false) dir.mkdirs(); } return dir; } /** * 返回指定的路径为 resources * * @param c * @return */ public String getDataDir(Class c) { //目录resolve File _currfile = new File(CURRFILE, &quot;resources&quot;); _currfile = this.rebuildDir(c, _currfile); System.out.println(TAG + &quot;::Using data directory::&quot; + _currfile.toString()); return _currfile.toString() + File.separator; } /** * 返回指定相对路径,相对的是user.dir * * @param c * @param desc * @return */ public String getDataDir(Class c, String desc) { File _currfile = new File(CURRFILE, &quot;resources&quot;); //目录resolve _currfile = new File(_currfile, desc); _currfile = this.rebuildDir(c, _currfile); System.out.println(TAG + &quot;::Using data directory::&quot; + _currfile.toString()); return _currfile.toString() + File.separator; } /** * 返回绝对路径的文件名组 * * @param floder * @return */ public ArrayList&lt;String&gt; getAllFile(String floder) { if (floder == null) { return null; } //存储文件名 ArrayList _allfilename = new ArrayList(); //获取当前的路径 File _currfile = new File(CURRFILE); //目录resolve _currfile = new File(_currfile, floder); if (!_currfile.exists()) { System.out.println(floder + &quot; not exists&quot;); return null; } File _dir[] = _currfile.listFiles(); for (int i = 0; i &lt; _dir.length; i++) { File fs = _dir[i]; if (fs.isDirectory()) { System.out.println(fs.getName() + “ [目录]”); } else { _allfilename.add(_currfile + “/“ + fs.getName()); } } return _allfilename; }}","link":"/2016/09/11/%E5%85%B6%E4%BB%96/Aspose-barcode-%E6%9D%A1%E7%A0%81%E5%92%8C%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%A4%84%E7%90%86/"},{"title":"Mac-Photoshop-cs6","text":"使用说明: 123456781、运行Block Adobe Activation，防止ADOBE激活程序启动，按操作提示点击即可。2、运行Adobe CS6安装程序3、选择“试用”4、输入Adobe ID，如果没有，免费注册一个，登录5、安装完之后，在Adobe Photoshop CS6程序按右键，选择显示包内容，打开/ Contents / Frameworks /文件夹，把amtlib.framework文件夹拷进去替换。6、同样道理，激活illustrator,indesign等程序，也是同样办法，在对应的Adobe CS6程序按右键，选择显示包内容，打开/ Contents / Frameworks /文件夹，把amtlib.framework文件夹拷进去替换。7、运行Adobe 程序，激活成功。享受ADOBE CS6吧！ 下载链接: https://pan.baidu.com/s/1ciesRO 密码: f95w","link":"/2016/09/11/%E5%B7%A5%E5%85%B7/Mac-Photoshop-cs6/"},{"title":"如何更有效地使用谷歌搜索-Chrome","text":"排除条件 相关条件、相关网站 关联文档、电影、PDF等等 站内搜索","link":"/2016/09/11/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%9C%89%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2-Chrome/"},{"title":"oracle-关于生成包-存储过程","text":"12345678create or replace package body package_memo is procedure one_procedure is end one_procedure ;end package_memo ;","link":"/2016/09/11/%E5%B7%A5%E5%85%B7/oracle-%E5%85%B3%E4%BA%8E%E7%94%9F%E6%88%90%E5%8C%85-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"title":"图像处理-ImageMagick-+-im4java","text":"注意先下载所需要的各类依赖之后再装主题ImageMagick 1234参考记录:http://blog.csdn.net/cloudsben/article/details/8164047 api 的链接 1234567im4java:http://im4java.sourceforge.net/api/org/im4java/core/IMOps.html对应的imageMagick的命令行:http://www.imagemagick.org/script/mogrify.php","link":"/2016/09/11/%E5%85%B6%E4%BB%96/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-ImageMagick-+-im4java/"},{"title":"yummyftp-激活码","text":"Name: Special [K]Serial: YUMFTP101-5S6J-LBFK-WL1F-W2WM-8WV1","link":"/2016/09/11/%E5%B7%A5%E5%85%B7/yummyftp-%E6%BF%80%E6%B4%BB%E7%A0%81/"},{"title":"基于-JetBrains-DataGrip-之-Oracle-PL-SQL-攻略--(二)","text":"对异常的检测 1234567EXCEPTIONWHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('无相关匹配的信息');WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE('实际返回的行数超出请求的行数'); 使用游标从数据库中检索单行数据,进行两个的FETCH,进而判断结果 123456789101112131415161718192021222324252627282930313233343536373839404142DECLARE --创建一个游标 CURSOR emp_cursor IS SELECT first_name, last_name, email FROM employees WHERE employee_id = &amp;emp_id; first VARCHAR2(20); last VARCHAR2(25); email VARCHAR2(25);BEGIN --打开游标 OPEN emp_cursor; FETCH emp_cursor INTO first, last, email; IF emp_cursor%NOTFOUND THEN RAISE NO_DATA_FOUND; ELSE -- 第二次查找,判断异常 FETCH emp_cursor INTO first, last, email; IF emp_cursor%FOUND THEN -- 抛出异常 RAISE TOO_MANY_ROWS; ELSE DBMS_OUTPUT.PUT_LINE( 'Employee Information for ID: ' || first || ' ' || last || ' - ' || email); END IF; END IF; --关闭游标 CLOSE emp_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('No employee matches the given ID'); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE('More than one employee matches the given ID');END;/ 限定列名与变量名–&gt;尽量不一样否者用 圆点标记法利用存储过程限定变量名,也可以使用代码块进行限定… 查询结果返回到PL/SQL 记录中 1234567891011121314151617181920212223242526272829DECLARE CURSOR wms_goods_cur IS SELECT GOODSID, GOODSNAME, GOODSINVNAME FROM WMS_GOODS WHERE GOODSID = 1000020598; --记录表的行结构 wms_good wms_goods_cur%ROWTYPE;BEGIN OPEN wms_goods_cur; FETCH wms_goods_cur INTO wms_good; IF wms_goods_cur%FOUND THEN CLOSE wms_goods_cur; DBMS_OUTPUT.PUT_LINE('药品的id:'|| wms_good.GOODSID || ' 药品的名称: ' || wms_good.GOODSNAME || ' 药品的别称: ' || wms_good.GOODSINVNAME); ELSE DBMS_OUTPUT.PUT_LINE('没有匹配到的药品'); END IF; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('无匹配的系你');END;/ 关于自定义数据结构来接收查询结果 1234567891011121314151617181920212223242526272829DECLARE -- 声明数据结构 TYPE wms_goods_info IS RECORD (id WMS_GOODS.GOODSID%TYPE, name WMS_GOODS.GOODSNAME%TYPE, invname WMS_GOODS.GOODSINVNAME%TYPE); -- 使用数据接口的变量 wms_good_rec wms_goods_info;BEGIN -- 填充变量 SELECT GOODSID, GOODSNAME, GOODSINVNAME INTO wms_good_rec FROM WMS_GOODS WHERE GOODSID = 1000005274; -- 输出 DBMS_OUTPUT.PUT_LINE('药品的id:' || wms_good_rec.id || ' 药品的名称: ' || wms_good_rec.name || ' 药品的别称: ' || wms_good_rec.invname); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('无匹配信息');END;/ 循环遍历查询的行结果 1234567891011121314151617181920212223242526272829303132333435363738--方案一:直接在 IN 后接一个查询语句SET SERVEROUTPUT ON;BEGIN DBMS_OUTPUT.ENABLE(1000000); FOR wms_goods IN ( SELECT GOODSID, GOODSNAME, GOODSINVNAME FROM WMS_GOODS WHERE GOODSID IS NOT NULL ) LOOP DBMS_OUTPUT.PUT_LINE(wms_goods.GOODSID || ' ' || wms_goods.GOODSNAME || ' - ' || wms_goods.GOODSINVNAME); END LOOP;END;/--方案二:构建CURSOR,然后在IN后遍历该游标SET SERVEROUTPUT ON;DECLARE CURSOR wms_goods IS SELECT GOODSID, GOODSNAME, GOODSINVNAME FROM WMS_GOODS WHERE GOODSID IS NOT NULL; emp_rec wms_goods%ROWTYPE;BEGIN FOR emp_rec IN wms_goods LOOP DBMS_OUTPUT.PUT_LINE(emp_rec.GOODSID || ' ' || emp_rec.GOODSNAME || ' - ' || emp_rec.GOODSINVNAME); END LOOP;END;/ 获取环境与会话的信息 1234567891011121314151617181920DECLARE username VARCHAR2(100); ip_address VARCHAR2(100);BEGIN SELECT -- 可自定义设置命名空间 另外 USERENV 的参数列表可参考 -- https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions165.htm SYS_CONTEXT('USERENV', 'SESSION_USER'), SYS_CONTEXT('USERENV', 'IP_ADDRESS') INTO username, ip_address FROM DUAL; DBMS_OUTPUT.PUT_LINE('The connected user is: ' || username || ', and the IP address is ' || ip_address);END obtain_user_info;/","link":"/2016/09/11/%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8E-JetBrains-DataGrip-%E4%B9%8B-Oracle-PL-SQL-%E6%94%BB%E7%95%A5--(%E4%BA%8C)/"},{"title":"部署-Nginx","text":"开机启动sudo update-rc.d -f nginx defaults 启动sudo /etc/init.d/nginx start 查看配置的文件nginx -t 后台启动nohup redis-server &amp;","link":"/2016/09/11/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2-Nginx/"},{"title":"基于-JetBrains-DataGrip-之-Oracle-PL-SQL-攻略--(一)","text":"在文集下的所有操作都是基于在 JetBrains DataGrip 上运行,图片的截图是快捷键的名字,请自行修改… 启动 DBMS_OUTPUT.PUT_LINE 功能 和 修改 dialog 创建代码块 代码循环:从10倒数到0 1234567891011SET SERVEROUTPUT ON;DECLARE counter NUMBER;BEGIN FOR counter IN REVERSE 0..10 LOOP DBMS_OUTPUT.PUT_LINE (counter); END LOOP;END;/ 命令行或者中断执行脚本 sqlplus username/password@database object.sql 接受用户键盘输入(替换变量),输出的是一条提示消息,若多条就需要循环遍历出来 1234567891011121314151617181920212223242526272829303132SET SERVEROUTPUT ON SIZE 1000000;DECLARE id NUMBER;BEGIN SELECT SODTLID INTO id FROM AAAAAAA WHERE SOID = &amp;SOID AND ROWNUM &lt;= 1; DBMS_OUTPUT.PUT_LINE(id);END;/原理剖析: 关键是使用了 &amp;符号 进行赋值,若想在其他的地方进行引用替换变量,则在键入 &amp;&amp; 符号用来存储该值... 也可以在DECLARE声明如下:SET SERVEROUTPUT ON SIZE 1000000;DECLARE souid_input NUMBER := &amp;SOID; id NUMBER;BEGIN SELECT SODTLID INTO id FROM AAAAAAA WHERE SOID = souid_input AND ROWNUM &lt;= 1; DBMS_OUTPUT.PUT_LINE(id);END; 需要注意的是,如果声明的值的类型是变长字符型 VARCHAR2 ,则使用 单括号. obj VARCHAR(2) := '&amp;String'; 注释 12345-- 这句话是注释/* 这是注释 */ 引用代码块,好像不支持,提示出报错 &lt;&lt;dept_block&gt;&gt; 忽略替换变量 '\\' 、还可以使用 SET DEFINE OFF ,另外 SET ESCAPE 设置转义字符 改变替换变量字符 SET DEFINE ^ 进行声明,之后就可以使用 ^ 代替 &amp; 创建匹配数据库列类型的变量,在DECLAR声明,该优势在会随原型变化而变化…. id AAAAAAA.SODTLID%TYPE; 使用正则过滤无用的数据库表 1234567^.[^0-9]*?(?&lt;!BACKUP)(?&lt;!BK)(?&lt;!LOG)(?&lt;!TMP)(?&lt;!BAK)(?&lt;!TEMP)(?&lt;!TEST)$(SYS_HM).*table:(SYS_HM).*|| table:(WK_).* || view:(HM_).* || view:(WK_).* 配置常用的JVM 内存 123-Xms720m -Xmx2048m","link":"/2016/09/11/%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8E-JetBrains-DataGrip-%E4%B9%8B-Oracle-PL-SQL-%E6%94%BB%E7%95%A5--(%E4%B8%80)/"},{"title":"配置-VPN-常用操作","text":"启动service iptables restartchkconfig iptables on service pptpd restartchkconfig pptpd onclear 添加用户vi /etc/ppp/chap-secrets","link":"/2016/09/11/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2-VPN-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"部署-安装 FTP","text":"vsftpd 组件 yum -y install vsftpd 查看当前用户 cat /etc/passwd 启动 vsftpd start service vsftpd start 安装ftp 客户端 yum -y install ftp 尝试登陆 ftp localhost 取消匿名登陆, anonymous_enable=YES ，改为NO vi /etc/vsftpd/vsftpd.conf 创建用户名修改密码 useradd ftpuser passwd ftpuser","link":"/2016/09/11/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2-%E5%AE%89%E8%A3%85FTP-/"},{"title":"部署-安装-Node","text":"安装 node 更新yum yum -y update 安装nvm –&gt;https://github.com/creationix/nvm wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash 列出node的最新版本 nvm ls-remote 安装指定的版本 / 使用 nvm install 6.2.1 / nvm use **","link":"/2016/09/11/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2-%E5%AE%89%E8%A3%85-Node/"},{"title":"jersey-2-x-记录","text":"Jersey 12345678910使用URI支持MIME类型的响应数据，包括JSON/XML/JPEG等使用HTTP GET/POST/DELETE/PUT（对应查找、新增、删除、修改）###JSR 311(JAX-RS)和Jersey Jersey是JSR 311的Java实现，可以快速的实现RESTful Web Service。Jersey的最新版本为2.6。其主要包含三个部分：核心服务器（Core Server）：通过提供JSR 311 中标准化的注释和API 标准化，您可以用直观的方式开发RESTful Web 服务核心客户端（Core Client）：Jersey 客户端API 帮助您与REST 服务轻松通信。集成（Integration）：Jersey 还提供可以轻松集成Spring、Guice、Apache Abdera 的库。 依赖包 123456789commons-beanutils.jarcommons-lang.jarcommons-logging.jarezmorph-1.0.2.jarjavax.servlet.api.jarjavax.ws.rs-api : 处理媒体类型等json-lib.jar 常用注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@Path 定义资源的相对URI@GET 意味着以下方法可以响应HTTP GET方法@Produces 响应的MIME类型@Path(&quot;/users/{username}&quot;)这个例子中，{username}即为用户输入的数据，例如用户输入Weiwei，则URL定位到 http://example.com/users/Weiwei对应的组件: public String getUser(@PathParam(&quot;username&quot;) String userName) { ... }一个@Path的内容是否以&quot;/&quot;开头都没有区别，同样是否以&quot;/&quot;结尾也没有什么区别@Path 位于方法上便是 子资源 分两种方式:@Produces(&quot;text/plain&quot;)指定了资源所产生和发送给 客户端的MIME类型，这里指定了类型为纯文本类型。@Produces 会覆盖类层面的@Produces@Produces({&quot;application/xml&quot;, &quot;application/json&quot;})public String doGetAsXmlOrJson() { ...}@Consumes({&quot;application/xml&quot;, &quot;application/json&quot;})指定所消费的类型的格式，这里指定为XML和JSON，即可以 接收 这种类型格式的文件作为输入。所有媒体类型(*/*)byte[]java.lang.Stringjava.io.Reader (inbound only)java.io.Filejavax.activation.DataSourcejavax.ws.rs.core.StreamingOutput (outbound only)XML 媒体类型 (text/xml, application/xml and application/...+xml)javax.xml.transform.Sourcejavax.xml.bind.JAXBElement应用了 JAXB 类的应用 (使用了 @XmlRootElement 或者 @XmlType 的类型)Form 表单内容(application/x-www-form-urlencoded)MultivaluedMap纯文本 (text/plain)java.lang.Booleanjava.lang.Characterjava.lang.Number@FormParam稍有特殊，因为它提取信息，先是请求所表示的MIME媒体类型为 application/x-www-form-urlencoded，并且符合指定的 HTML 编码的形式，正如这里所描述的。此参数提取对于 HTML 表单请求是非常有用的@FormParam 注释是特别的，仅可利用资源和子资源的方法。这是因为它从请求实体中提取信息@MatrixParam 从 URL 路径提取信息. @HeaderParam 从 HTTP 头部提取信息。 @CookieParam从关联在 HTTP 头部的 cookies 里提取信息。@BeanParam 用法 , 相当于把参数放进去 public class MyBeanParam { @PathParam(&quot;p&quot;) private String pathParam; @MatrixParam(&quot;m&quot;) @Encoded @DefaultValue(&quot;default&quot;) private String matrixParam; @HeaderParam(&quot;header&quot;) private String headerParam; private String queryParam; public MyBeanParam(@QueryParam(&quot;q&quot;) String queryParam) { this.queryParam = queryParam; } public String getPathParam() { return pathParam; } ...}@POSTpublic void post(@BeanParam MyBeanParam beanParam, String entity) { final String pathParam = beanParam.getPathParam(); // contains injected path parameter &quot;p&quot; ...}@Singleton 资源将是单例模式，不受请求范围管理,子资源定位方法返回一个类，这意味着运行时将托管资源的实例及其生命周期。相反，如果方法返回的是实例，那么注释将没有效果，返回的实例将被使用。@Path(&quot;/item&quot;)public class ItemResource { @Path(&quot;content&quot;) public Class&lt;ItemContentSingletonResource&gt; getItemContentResource() { return ItemContentSingletonResource.class; }}@Singletonpublic class ItemContentSingletonResource { // this class is managed in the singleton life cycle} 注入规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Path(&quot;{id:\\\\d+}&quot;)public class InjectedResource { // 注入到属性 @DefaultValue(&quot;q&quot;) @QueryParam(&quot;p&quot;) private String p; // 注入到构造函数参数 public InjectedResource(@PathParam(&quot;id&quot;) int id) { ... } // 注入到资源参数 @GET public String get(@Context UriInfo ui) { ... } // 注入子资源方法参数 @Path(&quot;sub-id&quot;) @GET public String get(@PathParam(&quot;sub-id&quot;) String id) { ... } // 注入子资源方法参数定位器方法参数 @Path(&quot;sub-id&quot;) public SubResource getSubResource(@PathParam(&quot;sub-id&quot;) String id) { ... } // 注入 bean setter 方法 @HeaderParam(&quot;X-header&quot;) public void setHeader(String header) { ... }}@Path(&quot;resource&quot;)public static class SummaryOfInjectionsResource { @QueryParam(&quot;query&quot;) String param; // injection into a class field 注入类的属性 @GET public String get(@QueryParam(&quot;query&quot;) String methodQueryParam) { // injection into a resource method parameter 注入资源的方法参数 return &quot;query param: &quot; + param; } @Path(&quot;sub-resource-locator&quot;) public Class&lt;SubResource&gt; subResourceLocator(@QueryParam(&quot;query&quot;) String subResourceQueryParam) { // injection into a sub resource locator parameter注入子资源定位器参数 return SubResource.class; } public SummaryOfInjectionsResource(@QueryParam(&quot;query&quot;) String constructorQueryParam) { // injection into a constructor parameter注入构造器的参数 } @Context public void setRequest(Request request) { // injection into a setter method注入setter方法 System.out.println(request != null); }}public static class SubResource { @GET public String get() { return &quot;sub resource&quot;; }} 应用的部署和运行时的环境 ResourceConfig 简化组件的注册,如扫描根资源、类提供者提供的路径或一组包名的集合。所有 JAX-RS 组件类都会手动注册或者扫描期间找到的类都会自动添加到 getClasses 所返回的类的集合中,另外部署时可参考Servlet容器模型（二）部署描述文件 123456789101112131415161718192021222324252627282930313233343536public class MyApplication extends ResourceConfig { public MyApplication() { register(org.glassfish.jersey.server.filter.UriConnegFilter.class); register(org.glassfish.jersey.server.validation.ValidationFeature.class); register(org.glassfish.jersey.server.spring.SpringComponentProvider.class); register(org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider.class); property(ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE, true); }} &lt;servlet&gt; &lt;servlet-name&gt;Jersey Web Application&lt;/servlet-name&gt; &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt; &lt;param-value&gt;com.gzmpc.pc.MainApp&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;Servlet&gt;元素1、&lt;servlet-name&gt;元素：必须选，定义servlet名称，在DD文件中应该唯一，可通过servletConfig的getServletName()方法检索；2、&lt;servlet-class&gt;元素：制定servlet完整名称，需带包WEB-INF目录中的classes目录和lib目录中JAR文件会被自动添加到容器的类路径中，不需设置类路径3、&lt;init-param&gt;元素：向servlet传递初始化参数，每个&lt;int-param&gt;有仅有一组&lt;param-name&gt;和&lt;param-value&gt;子元素，可通过ServletConfig接口的getInitParameter()方法检索初始化参数；4、&lt;load-on-startup&gt;元素：一般的servlet是在被请求时由容器装入内存，这只一个正数则在启动时载入该servlet，值小的优先装入，负数或者没有指定，容器将根据需要决定何时装入servlet 使用 Spring Data JPA 简化 JPA 开发 MIME类型大全","link":"/2016/09/11/%E5%85%B6%E4%BB%96/jersey-2-x-%E8%AE%B0%E5%BD%95/"},{"title":"angular-$watch","text":"$watch(watchFn, watchAction, deepWatch) 字符串或者表达式,方法,深watch(一般是数组或者对象) 监听 与 注销 var dereg = $scope.$watch(‘someModel.someProperty’, callbackOnChange()); dereg();","link":"/2016/09/11/angular/angular-$watch/"},{"title":"angular-$scope变量和方法","text":"变量和方法的使用$scope 类似是一个代理的对象,负责增删改和检验等功能 ng-click=”login()” $scope 生成 $scope.user = { name: ‘’, pwd: ‘’ }; $scope 引用 12345678910111213141516&lt;body style=&quot;padding:10px;&quot; ng-app=&quot;app&quot;&gt;&lt;div ng-controller=&quot;MyCtrl&quot;&gt;&lt;input type=&quot;text&quot;ng-model=&quot;msg&quot;&gt;&lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;br&gt;&lt;h1&gt;{{reverse()}}&lt;/h1&gt;&lt;!--调用方法，注意这里要加括号--&gt;&lt;/div&gt;&lt;div ng-controller=&quot;MyCtrl&quot;&gt;&lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;input type=&quot;text&quot; ng-model=&quot;user.pwd&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;div ng-click=&quot;login()&quot;&gt;登录&lt;/div&gt;&lt;div ng-show=&quot;errormsg.length&gt;0&quot;&gt;{{errormsg}}&lt;/div&gt;&lt;!--当errormsg长度大于0的时候显示出来--&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920angular.module('app', []).controller('MyCtrl',function($scope) { $scope.msg = &quot;&quot;; $scope.reverse = function() { return $scope.msg.split(&quot;&quot;).reverse().join(&quot;&quot;); &lt; !--对输入进行反转--&gt; } $scope.user = { name: '', pwd: '' }; $scope.errormsg = &quot;&quot;; &lt; !--需要先定义，否则会报错--&gt;$scope.login = function() { if ($scope.user.name == &quot;admin&quot; &amp;&amp; $scope.user.pwd == &quot;123&quot;) { alert(&quot;登录成功&quot;); } else { alert(&quot;用户名或密码错误&quot;); } }})","link":"/2016/09/11/angular/angular-$scope%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"angular-constant","text":"归属module 代表常量123456789101112var app = angular.module('myapp', []).value('testvalue', 'widuu').constant('count', 23).service('testservice',function(testvalue, count) { this.lable = function() { return &quot;this will output:hello &quot; + testvalue + &quot;,age is &quot; + count; }});app.controller('mytest',function($scope, testvalue, testservice) { $scope.test = &quot;hello &quot; + testvalue; $scope.output = testservice.lable();});","link":"/2016/09/11/angular/angular-constant/"},{"title":"angular-css类和样式","text":"123456&lt;div ng-controller=&quot;MenuController&quot;&gt; &lt;ul&gt; &lt;li class=&quot;menu-disabled-{{isDisabled}}&quot; ng-click=&quot;DisabledIt()&quot;&gt;Click&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; 123.menu-disabled-true { color: gray;} 1234567function MenuController($scope) { $scope.isDisabled = false; $scope.disabledIt = function() { $scope.isDisabled = true; }}","link":"/2016/09/11/angular/angular-css%E7%B1%BB%E5%92%8C%E6%A0%B7%E5%BC%8F/"},{"title":"angular-controller","text":"是module的方法controller(name, constructor);前者是名字,后者是构造函数不同的controller中变量相同引用不同 1234567891011121314&lt;body style=&quot;padding:10px;&quot; ng-app=&quot;app&quot;&gt;&lt;div ng-controller=&quot;FirstCtrl&quot;&gt;&lt;input type=&quot;text&quot;ng-model=&quot;msg&quot;&gt;&lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;br&gt;&lt;h1 ng-bind=&quot;msg&quot;&gt;&lt;/h1&gt;&lt;!--可以使用ng-bind进行绑定，这样就不需要输入{{}}--&gt;&lt;/div&gt;&lt;div ng-controller=&quot;SecondCtrl&quot;&gt;&lt;input type=&quot;text&quot; ng-model=&quot;msg&quot;&gt;&lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;!--同样是msg，但是显示的不同这就是控制器作用域的问题，这个msg绑定的是SecondCtrl--&gt;&lt;/div&gt;&lt;/body&gt; 1234567angular.module('app',[]).controller('FirstCtrl',function($scope){ $scope.msg=&quot;hello angular&quot;;}).controller('SecondCtrl',function($scope){ $scope.msg=&quot;hello angularjs&quot;}) 比较正式的控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849angular.module('myApp', []).controller('userCtrl', function($scope) {$scope.fName = '';$scope.lName = '';$scope.passw1 = '';$scope.passw2 = '';$scope.users = [{id:1, fName:'Hege',lName:&quot;Pege&quot; },{id:2, fName:'Kim',lName:&quot;Pim&quot; },{id:3, fName:'Sal',lName:&quot;Smith&quot; },{id:4, fName:'Jack',lName:&quot;Jones&quot; },{id:5, fName:'John',lName:&quot;Doe&quot; },{id:6, fName:'Peter',lName:&quot;Pan&quot; }];$scope.edit = true;$scope.error = false;$scope.incomplete = false; $scope.editUser = function(id) { if (id == 'new') { $scope.edit = true; $scope.incomplete = true; $scope.fName = ''; $scope.lName = ''; } else { $scope.edit = false; $scope.fName = $scope.users[id-1].fName; $scope.lName = $scope.users[id-1].lName; }};$scope.$watch('passw1',function() {$scope.test();});$scope.$watch('passw2',function() {$scope.test();});$scope.$watch('fName',function() {$scope.test();});$scope.$watch('lName',function() {$scope.test();});$scope.test = function() { if ($scope.passw1 !== $scope.passw2) { $scope.error = true; } else { $scope.error = false; } $scope.incomplete = false; if ($scope.edit &amp;&amp; (!$scope.fName.length || !$scope.lName.length || !$scope.passw1.length || !$scope.passw2.length)) { $scope.incomplete = true; }};})","link":"/2016/09/11/angular/angular-controller/"},{"title":"angular-JQuery-的-数据获取","text":"jquery123456789$.ajax({ url: '/myEndpoint.json', success: function ( data, status ) { $('ul#log').append('&lt;li&gt;Data Received!&lt;/li&gt;'); }});&lt;ul class=&quot;messages&quot; id=&quot;log&quot;&gt;&lt;/ul&gt; angular1234567$http( '/myEndpoint.json' ).then( function ( response ) { $scope.log.push( { msg: 'Data Received!' } );});&lt;ul class=&quot;messages&quot;&gt; &lt;li ng-repeat=&quot;entry in log&quot;&gt;{{ entry.msg }}&lt;/li&gt;&lt;/ul&gt;","link":"/2016/09/11/angular/angular-JQuery-%E7%9A%84-%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"title":"angular-factory","text":"是module的方法factory(name, providerFunction);存储方法 1234&lt;body ng-app='myapp' ng-controller='mytest'&gt; &lt;input ng-model='test'&gt;{{test}} &lt;br&gt;{{output}}&lt;/body&gt; 1234567891011121314var app = angular.module('myapp', []).value('testvalue', 'widuu').factory('testfactory',function(testvalue) { return { lable: function() { return &quot;this can output : hello &quot; + testvalue; } }});app.controller('mytest',function($scope, testvalue, testfactory) { $scope.test = &quot;hello &quot; + testvalue; $scope.output = testfactory.lable();});","link":"/2016/09/11/angular/angular-factory/"},{"title":"angular-restrict作用","text":"‘A’ 仅匹配属性名字 - ‘E’ 仅匹配元素名字 - ‘AE’ 可以匹配到属性名字或者元素名 什么时候使用属性名或元素名呢？ 当创建一个含有自己模板的组件的时候，需要使用元素名，如果仅仅是为已有的元素添加功能的话，使用属性名。 使用元素名做为myCustomer指令是非常正确的决定，因为你不是用一些’customer’行为来点缀元素，而是定义一个具有自己行为的元素作为customer组件。","link":"/2016/09/11/angular/angular-restrict%E4%BD%9C%E7%94%A8/"},{"title":"angular-service","text":"归属module (name, constructor)提供一个服务与factory 相似 123456789101112var app = angular.module('myapp', []).value('testvalue', 'widuu').service('testservice',function(testvalue) { this.lable = function() { return &quot;this will output:hello &quot; + testvalue; }});app.controller('mytest',function($scope, testvalue, testservice) { $scope.test = &quot;hello &quot; + testvalue; $scope.output = testservice.lable();});","link":"/2016/09/11/angular/angular-service/"},{"title":"angular-value","text":"是module的方法类似键值对的感觉存储值 123&lt;body ng-app='myapp' ng-controller='mytest'&gt; &lt;input ng-model='test'&gt;{{test}}&lt;/body&gt; 123456var app = angular.module('myapp', []).value('testvalue', 'word');app.controller('mytest',function($scope, testvalue) { $scope.test = &quot;hello &quot; + testvalue;});","link":"/2016/09/11/angular/angular-value/"},{"title":"angular-provider","text":"归属module (name, providerType)类似 factory用于提供一个方法 1234567891011121314var app = angular.module('myapp', []).value('testvalue', 'widuu').provider('testprovider',function() { this.lable = &quot;this will output : hello widuu&quot;; this.$get = function() { return this; }});app.controller('mytest',function($scope, testvalue, testprovider) { $scope.test = &quot;hello &quot; + testvalue; $scope.output = testprovider.lable;});","link":"/2016/09/11/angular/angular-provider/"},{"title":"angular-入门","text":"12345678910111213&lt;!doctype html&gt;&lt;html lang=&quot;zh&quot; ng-app&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Your name: &lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&gt;&lt;hr&gt;Hello {{yourname || 'xudaolong'}}!&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2016/09/11/angular/angular-%E5%85%A5%E9%97%A8/"},{"title":"angular-创建自定义指令","text":"检测是否内嵌表达式=&gt;watches,在digest循环中更新$interpolateHello ! 优先返回对象而不是函数 优先保留你自己的指令作为前缀 模板扩展的指令:但是标签名是无效的 对应的html: 1234567&lt;div my-customer&gt;&lt;/div&gt;.directive('myCustomer', function() { return { template: 'Name: {{customer.name}} Address: {{customer.address}}' }; }); 若是大量的模板的: 12345678&lt;div my-customer&gt;&lt;/div&gt;.directive('myCustomer', function() { return { restrict: 'E', templateUrl: 'my-customer.html' }; }); // my-customer.htmlName: Address:","link":"/2016/09/11/angular/angular-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"title":"angular-扩展html","text":"1.先定义了模块,在选择选择器 指令: ng-appangular模块作用域 ng-model标签变量 组合指令: ng-init初始化变量 ng-bind ng-controllerangular控制器","link":"/2016/09/11/angular/angular-%E6%89%A9%E5%B1%95html/"},{"title":"angular-事件绑定","text":"12345678910ng-changeng-clickng-dblclickng-mousedownng-mouseenterng-mouseleaveng-mousemoveng-mouseoverng-mouseupng-submit 对于事件对象本身，在函数调用时可以直接使用 $event 进行传递： 12&lt;p ng-click=&quot;click($event)&quot;&gt;点击&lt;/p&gt;&lt;p ng-click=&quot;click($event.target)&quot;&gt;点击&lt;/p&gt;","link":"/2016/09/11/angular/angular-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"title":"angular-包含","text":"感觉有点类似自定义指定","link":"/2016/09/11/angular/angular-%E5%8C%85%E5%90%AB/"},{"title":"angular-控件间的传值","text":"基于原型继承 父类的更改会触发所有的子类,子类的修改只会自身 12345678&lt;div ng-controller=&quot;Sandcrawler&quot; ng-app&gt; &lt;p&gt;Location: {{location}}&lt;/p&gt; &lt;button ng-click=&quot;move('Mos Eisley South')&quot;&gt;Move&lt;/button&gt; &lt;div ng-controller=&quot;Droid&quot;&gt; &lt;p&gt;Location: {{location}}&lt;/p&gt; &lt;button ng-click=&quot;sell('Owen Farm')&quot;&gt;Sell&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011function Sandcrawler($scope) { $scope.location = &quot;Mos Eisley North&quot;; $scope.move = function(newLocation) { $scope.location = newLocation; }}function Droid($scope) { $scope.sell = function(newLocation) { $scope.location = newLocation; }} 基于事件的方式 on 注册事件 并由 emit 触发 向上 1234567&lt;div ng-controller=&quot;Sandcrawler&quot; ng-app&gt; &lt;p&gt;Sandcrawler Location: {{location}}&lt;/p&gt; &lt;div ng-controller=&quot;Droid&quot;&gt; &lt;p&gt;Droid Location: {{location}}&lt;/p&gt; &lt;button ng-click=&quot;summon()&quot;&gt;Summon Sandcrawler&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112function Sandcrawler($scope) { $scope.location = &quot;Mos Eisley North&quot;; $scope.$on('summon', function(e, newLocation) { $scope.location = newLocation; });}function Droid($scope) { $scope.location = &quot;Owen Farm&quot;; $scope.summon = function() { $scope.$emit('summon', $scope.location); }} 向下 123456789101112function Sandcrawler($scope) { $scope.location = &quot;Mos Eisley North&quot;; $scope.recall = function() { $scope.$broadcast('recall', $scope.location); }}function Droid($scope) { $scope.location = &quot;Owen Farm&quot;; $scope.$on('recall', function(e, newLocation) { $scope.location = newLocation; });} 12345678//html&lt;div ng-controller=&quot;Sandcrawler&quot;&gt; &lt;p&gt;Sandcrawler Location: {{location}}&lt;/p&gt; &lt;button ng-click=&quot;recall()&quot;&gt;Recall Droids&lt;/button&gt; &lt;div ng-controller=&quot;Droid&quot;&gt; &lt;p&gt;Droid Location: {{location}}&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 兄弟之间的传播 1234567891011121314function Sandcrawler($scope) { $scope.$on('requestDroidRecall', function(e) { $scope.$broadcast('executeDroidRecall'); });}function Droid($scope) { $scope.location = &quot;Owen Farm&quot;; $scope.recallAllDroids = function() { $scope.$emit('requestDroidRecall'); } $scope.$on('executeDroidRecall', function() { $scope.location = &quot;Sandcrawler&quot; });} 12345678910111213// html&lt;div ng-controller=&quot;Sandcrawler&quot;&gt; &lt;div ng-controller=&quot;Droid&quot;&gt; &lt;h2&gt;R2-D2&lt;/h2&gt; &lt;p&gt;Droid Location: {{location}}&lt;/p&gt; &lt;button ng-click=&quot;recallAddDroids()&quot;&gt;Recall All Droids&lt;/button&gt; &lt;/div&gt; &lt;div ng-controller=&quot;Droid&quot;&gt; &lt;h2&gt;C-3PO&lt;/h2&gt; &lt;p&gt;Droid Location: {{status}}&lt;/p&gt; &lt;button ng-click=&quot;recallAddDroids()&quot;&gt;Recall All Droids&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;","link":"/2016/09/11/angular/angular-%E6%8E%A7%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/"},{"title":"angular-自定义指令","text":"指令使用如下,由restrict控制 1234E 元素方式 &lt;my-directive&gt;&lt;/my-directive&gt;A 属性方式 &lt;div my-directive=&quot;exp&quot;&gt; &lt;/div&gt;C 类方式 &lt;div class=&quot;my-directive: exp;&quot;&gt;&lt;/div&gt;M 注释方式 &lt;!-- directive: my-directive exp --&gt; 指令执行过程: 解析DOM结构–&gt;$compile–&gt;执行link函数 $compile 涉及: 变量占位符-指令-compile函数 指令的构造应该返回对象,若是函数则是作为compile的返回值 12345678910111213name:controller的名字priority:权重,决定兄弟节点的执行compile的顺序terminal:若为true,则权重小于但不等于的该节点的节点不会被执行.scope:false 节点的 scope ， true 继承创建一个新的 scope ， {} 不继承创建一个新的隔离 scope 。 {@attr: '引用节点属性', =attr: '把节点属性值引用成scope属性值', &amp;attr: '把节点属性值包装成函数'}controller:为指令自定义一个controller,function controller($scope, $element, $attrs, $transclude) { ... }require:?name 忽略不存在的错误， ^name 在父级查找restricttemplate:模板内容templateUrl:模板地址replace:true 替换整个节点， false 替换节点内容transclude:'element' 或 true 两种值 compilelink 关于动态渲染修改变量 12345678app.directive('color', function(){ var link = function($scope, $element, $attrs){ $scope.$watch($attrs.color, function(new_v){ $element.css('color', new_v); }); } return link;}); attributes对象 12345$element 属性所在的节点。$attr 所有的属性值（类型是对象）。$normalize 一个名字标准化的工具函数，可以把 ng-click 变成 ngClick 。$observe 为属性注册侦听器的函数。$set 设置对象属性，及节点属性的工具。","link":"/2016/09/11/angular/angular-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"title":"angular-模板节点控制","text":"样式 12&lt;div ng-style=&quot;{width: 100 + 'px', height: 100 + 'px', backgroundColor: 'red'}&quot;&gt;&lt;/div&gt; 类 12&lt;div ng-controller=&quot;TestCtrl&quot; ng-class=&quot;cls&quot;&gt;&lt;/div&gt; 显示和隐藏ng-show ng-hide ng-switch 前两个是控制 display 的指令： 1234&lt;div ng-show=&quot;true&quot;&gt;1&lt;/div&gt;&lt;div ng-show=&quot;false&quot;&gt;2&lt;/div&gt;&lt;div ng-hide=&quot;true&quot;&gt;3&lt;/div&gt;&lt;div ng-hide=&quot;false&quot;&gt;4&lt;/div&gt; 后一个 ng-switch 是根据一个值来决定哪个节点显示，其它节点移除： 1234567&lt;div ng-init=&quot;a=2&quot;&gt; &lt;ul ng-switch on=&quot;a&quot;&gt; &lt;li ng-switch-when=&quot;1&quot;&gt;1&lt;/li&gt; &lt;li ng-switch-when=&quot;2&quot;&gt;2&lt;/li&gt; &lt;li ng-switch-default&gt;other&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 其他属性ng-src 控制 src 属性： 1&lt;img ng-src=&quot;{{ 'h' + 'ead.png' }}&quot; /&gt; ng-href 控制 href 属性： 1&lt;a ng-href=&quot;{{ '#' + '123' }}&quot;&gt;here&lt;/a&gt; ng-src src属性ng-href href属性ng-checked 选中状态ng-selected 被选择状态ng-disabled 禁用状态ng-multiple 多选状态ng-readonly 只读状态","link":"/2016/09/11/angular/angular-%E6%A8%A1%E6%9D%BF%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6/"},{"title":"angular-模板内容、方式","text":"模板内容、方式 在需要的地方直接写字符串 外部文件 12345&lt;div ng-include src=&quot;'tpl.html'&quot;&gt;&lt;/div&gt;&lt;div ng-include=&quot;'tpl.html'&quot;&gt;&lt;/div&gt; 使用 script 标签定义的“内部文件” 12345&lt;script type=&quot;text/ng-template&quot; id=&quot;tpl&quot;&gt;here, {{ 1 + 1 }}&lt;/script&gt;&lt;div ng-include src=&quot;'tpl'&quot;&gt;&lt;/div&gt; 配合变量使用 123456&lt;script type=&quot;text/ng-template&quot; id=&quot;tpl&quot;&gt;here, {{ 1 + 1 }}&lt;/script&gt;&lt;a ng-click=&quot;v='tpl'&quot;&gt;Load&lt;/a&gt;&lt;div ng-include src=&quot;v&quot;&gt;&lt;/div&gt;","link":"/2016/09/11/angular/angular-%E6%A8%A1%E6%9D%BF%E5%86%85%E5%AE%B9%E3%80%81%E6%96%B9%E5%BC%8F/"},{"title":"angular-表单","text":"必须 name 和 ng-controller另外模板中的name便是$scope的层叠组件 例子一: 12345678910111213&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;a&quot; required ng-model=&quot;a&quot; /&gt; &lt;span ng-click=&quot;see()&quot;&gt;{{ test_form.$valid }}&lt;/span&gt;&lt;/form&gt;angular.module('app', [], angular.noop).controller('TestCtrl', function($scope){ $scope.see = function(){ console.log($scope.test_form); console.log($scope.test_form.a); }}); form 这个标签本身有一些动态类可以使用： 1234ng-valid 当表单验证通过时的设置ng-invalid 当表单验证失败时的设置ng-pristine 表单的未被动之前拥有ng-dirty 表单被动过之后拥有 form 对象的属性有： 12345$pristine 表单是否未被动过$dirty 表单是否被动过$valid 表单是否验证通过$invalid 表单是否验证失败$error 表单的验证错误 12345678910111213&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;a&quot; required ng-model=&quot;a&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;b&quot; required ng-model=&quot;b&quot; ng-minlength=&quot;2&quot; /&gt; &lt;span ng-click=&quot;see()&quot;&gt;{{ test_form.$error }}&lt;/span&gt;&lt;/form&gt;angular.module('app', [], angular.noop).controller('TestCtrl', function($scope){ $scope.see = function(){ console.log($scope.test_form.$error); }}); input 控件的相关可用属性为： 12345678name 名字ng-model 绑定的数据required 是否必填ng-required 是否必填ng-minlength 最小长度ng-maxlength 最大长度ng-pattern 匹配模式ng-change 值变化时的回调 select 12345678&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;a&quot; ng-model=&quot;a&quot; ng-true-value=&quot;AA&quot; ng-false-value=&quot;BB&quot; /&gt; &lt;span&gt;{{ a }}&lt;/span&gt;&lt;/form&gt;var TestCtrl = function($scope){ $scope.a = 'AA';} radio 12345&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;AA&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;BB&quot; /&gt; &lt;span&gt;{{ a }}&lt;/span&gt;&lt;/form&gt;","link":"/2016/09/11/angular/angular-%E8%A1%A8%E5%8D%95/"},{"title":"angular-模板内容渲染","text":"重复 1234$index 当前索引$first 是否为头元素$middle 是否为非头非尾元素$last 是否为尾元素 例子一: 12345&lt;div ng-controller=&quot;TestCtrl&quot;&gt; &lt;ul ng-repeat=&quot;member in obj_list&quot;&gt; &lt;li&gt;{{ member }}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345angular.module('app', [], angular.noop).controller('TestCtrl', function($scope){ $scope.obj_list = [1,2,3,4];});angular.bootstrap(document.documentElement, ['app']); 例子二: 12345&lt;div ng-controller=&quot;TestCtrl&quot;&gt; &lt;ul ng-repeat=&quot;member in obj_list&quot;&gt; &lt;li&gt;{{ $index }}, {{ member.name }}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345angular.module('app', [], angular.noop).controller('TestCtrl', function($scope){ $scope.obj_list = [{name: 'A'}, {name: 'B'}, {name: 'C'}];});angular.bootstrap(document.documentElement, ['app']); 奇偶ng-class-even 和 ng-class-odd 是和 ng-repeat 配合使用的： 123&lt;ul ng-init=&quot;l=[1,2,3,4]&quot;&gt; &lt;li ng-class-odd=&quot;'odd'&quot; ng-class-even=&quot;'even'&quot; ng-repeat=&quot;m in l&quot;&gt;{{ m }}&lt;/li&gt;&lt;/ul&gt; 赋值 12345&lt;div ng-controller=&quot;TestCtrl&quot; ng-init=&quot;a=[1,2,3,4];&quot;&gt; &lt;ul ng-repeat=&quot;member in a&quot;&gt; &lt;li&gt;{{ member }}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;","link":"/2016/09/11/angular/angular-%E6%A8%A1%E6%9D%BF%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93/"},{"title":"angular-获取列表中的值","text":"1234567891011&lt;li ng-repeat=&quot;tag in tags&quot;&gt; &lt;span ng-click=&quot;onSelect(tag)&quot;&gt;{{tag.name}}&lt;/span&gt;&lt;/li&gt; $scope.onSelect=function(tag){ $scope.selectedTag=tag.name;//将单击的值赋给$scope.selectedTag console.log(tag.name); console.log($scope.selectedTag) }","link":"/2016/09/11/angular/angular-%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%BC/"},{"title":"angular-隔离指令的作用域","text":"避免重复使用controller solate scope 12345678910111213141516171819202122232425262728293031var app = angular.module('myApp', []);app.controller('Ctrl', function($scope) { $scope.naomi = { name: 'Naomi', address: '1600 Amphitheatre' }; $scope.igor = { name: 'Igor', address: '123 Somewhere' }; }) .directive('myCustomer', function() { return { restrict: 'E', scope: { customer: '=customer' }, template: 'Name: {{customer.name}} Address: {{customer.address}}' }; });&lt;body ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;Ctrl&quot;&gt; &lt;my-customer customer=&quot;naomi&quot;&gt;&lt;/my-customer&gt; &lt;hr&gt; &lt;my-customer customer=&quot;igor&quot;&gt;&lt;/my-customer&gt; &lt;/div&gt;&lt;/body&gt; 关键在于: 123scope: { customer: '=customer'}, 简化: 1234scope: { // same as '=customer' customer: '='},","link":"/2016/09/11/angular/angular-%E9%9A%94%E7%A6%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"angular-表单输入","text":"input 的监听事件 ng-change Starting : Recommendation: 12345678function StartUpController($scope) { $scope.funding = { startingEstimate : 0}; $scope.computeNeeded = function () { $scope.funding.needed = $scope.funding.startingEstimate * 10; } } 检测数据是否变化 1$scope.$watch('funding.startingEstimate', computeNeeded);","link":"/2016/09/11/angular/angular-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5/"},{"title":"java-common-Lang-StringUtils","text":"概述介绍基本的功能 1234567891011121314151617181920212223242526272829IsEmpty/IsBlank(可含有whitespace) - 是否包含文本Trim/Strip(中间空的保留) - 删除前后空格Equals/Compare - 比较两个字符串startsWith - 是否以某字符串开始endsWith - 是否以某字符串结束IndexOf/LastIndexOf/Contains - 空字符串检测IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut - 是否包含哪些字符串ContainsOnly/ContainsNone/ContainsAny - 字符是否仅包含/不含有/任何这些字符串Substring/Left/Right/Mid - 截取字符串SubstringBefore/SubstringAfter/SubstringBetween - 提取相对其他字符串Split/Join - 分割/组合成数组Remove/Delete - 删除部分字符串Replace/Overlay - 搜索/替换字符串Chomp/Chop - 删除最后的字符串AppendIfMissing - 保持固定后缀PrependIfMissing - 保持固定前缀LeftPad/RightPad/Center/Repeat - 左/右/中/重复/地填充UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize - 改变字符串的大小写CountMatches - 计算此字符串在另外一个字符串出现的次数IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable - 检查字符串的类型DefaultString - 防止输入空值而设定默认值Rotate - 旋转字符串Reverse/ReverseDelimited - 逆转一个字符串Abbreviate - 将字符串省略化Difference - 字符串间的区别LevenshteinDistance - 两个字符串的具体值差距 除去上面那个比较常见的函数外,还有一些高级的… Empty : null 、 “” Blank : whitespace 、 null 、 “” 123456789101112131415161718192021isNotEmpty/isNotBlank : 确保不为空isAnyEmpty/isAnyBlank : 是否包含一个空字符串isNoneEmpty/isNoneBlank : 确保全部是有效值trimToNull/stripToNull : Blank元素转成 nulltrimToEmpty/stripToEmpty : Blank元素转成 &quot;&quot; truncate : 按前到后截断stripAll : 处理多个字符串stripAccents : 去除音标equalsIgnoreCase : 忽略大小比较","link":"/2016/09/11/apache-common/java-common-Lang-StringUtils/"},{"title":"docker-技术入门与实战-笔记","text":"开源图书&lt;&lt;docker 技术入门与实战&gt;&gt;传送门 1https://yeasy.gitbooks.io/docker_practice/content/ 有何作用 : 用了 Docker 技术后，直接把项目源代码和所有关联的软件、库等等全部打包成一个镜像，只要对方的机器里也安装了 Docker，直接把这个镜像放到容器里就行了，完全不用操心版本不匹配、依赖不全的问题。","link":"/2016/09/11/docker/docker-%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0/"},{"title":"jade-在express下调用","text":"在express 下调用1234567app.set('view engine', 'jade'); // 设置模板引擎app.set('views', __dirname); // 设置模板相对路径(相对当前目录)app.get('/', function(req, res) { res.render('test'); // 调用当前路径下的 test.jade 模板})","link":"/2016/09/11/express/jade-%E5%9C%A8express%E4%B8%8B%E8%B0%83%E7%94%A8/"},{"title":"apache-common-浅尝实操","text":"嘿嘿嘿,工作需要,又做回Java开发了…于是想熟悉一下常用的开发包…apache common 系列的包便是首选.. 以下是有必要需要了解的开发包–https://commons.apache.org/学习一些比较常用…一直有更新的包…对自己而言,如果没有时间看源码,至少也得会有,或者有一定的了解,你说,是吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//以下是更新至2014[BeanUtils](https://commons.apache.org/proper/commons-beanutils/)这个名字看起来很熟,那就先从这个开始咯...[Codec](https://commons.apache.org/proper/commons-codec/)[DbUtils](https://commons.apache.org/proper/commons-dbutils/)[Exec](https://commons.apache.org/proper/commons-exec/)[Logging](https://commons.apache.org/proper/commons-logging/)//以下更新至2015[Pool](https://commons.apache.org/proper/commons-pool/)[Math](https://commons.apache.org/proper/commons-math/)[Lang](https://commons.apache.org/proper/commons-lang/)[Jexl](https://commons.apache.org/proper/commons-jexl/)[Email](https://commons.apache.org/proper/commons-email/)[DBCP](https://commons.apache.org/proper/commons-dbcp/)[Collections](https://commons.apache.org/proper/commons-collections/)[CLI](https://commons.apache.org/proper/commons-cli/)//以下更新至2016[BCEL](https://commons.apache.org/proper/commons-bcel/)[Compress](https://commons.apache.org/proper/commons-compress/)[Configuration](https://commons.apache.org/proper/commons-configuration/)[Crypto](https://commons.apache.org/proper/commons-crypto/)[CSV](https://commons.apache.org/proper/commons-csv/)[FileUpload](https://commons.apache.org/proper/commons-fileupload/)[IO](https://commons.apache.org/proper/commons-io/)[Net](https://commons.apache.org/proper/commons-net/)[Validator](https://commons.apache.org/proper/commons-validator/)[Validator](https://commons.apache.org/proper/commons-validator/)[Weaver](https://commons.apache.org/proper/commons-weaver/)","link":"/2016/09/11/apache-common/apache-common-%E6%B5%85%E5%B0%9D%E5%AE%9E%E6%93%8D/"},{"title":"jade-语法格式","text":"相同123p | foo bar baz | rawr rawr 123p. foo bar baz rawr rawr 变量1234567#{表达式} --&gt;任何地方=表达式 --&gt;值!=表达式- var s = 'hello world' // 在服务端空间中定义变量p #{s}p= s 404页面1234567var error = #{error}if (error) p #{error}else h1 你想干嘛 -- 404 页面. error = Error: Not Found Error: Not Found","link":"/2016/09/11/express/jade-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"title":"java-common-Lang-CharSetUtils","text":"常用函数如下: 123456789101112static boolean containsAny(String str, String... set)接受一个参数集语法,看到evaluateSet, 并确定是否有任何的角色出现在指定的字符串中。static int count(String str, String... set)接受一个参数集语法,看到evaluateSet, 并返回指定数量的字符出现在字符串。static String delete(String str, String... set)接受一个参数集语法,看到evaluateSet, 和删除任何的字符出现在指定的字符串。static String keep(String str, String... set)接受一个参数集语法,看到evaluateSet, 并保持任何的字符出现在指定的字符串。static String squeeze(String str, String... set)根据参数二set提供的字母序列,删除重复的字符 测试用例 1234567891011121314151617181920212223242526272829303132333435/** * 文 件 名: TestCharSetUtils * 创 建 人: xudaolong * 创建日期: 16/7/23 14:09 * 邮 箱: xudaolong@vip.qq.com * 博 客: http://xudaolong.github.io/ * 修改时间： * 修改备注： */public class TestCharSetUtils { public static Logger log = Logger.getLogger(TestCharSetUtils.class); @Test public void TestCharSet() { String memo = &quot;xudaollong&quot;; /** * 好像都是些过滤的作用而已 */ //是否包含指定的字母列 log.info(CharSetUtils.containsAny(memo, &quot;a-v&quot;)); //删除指定的字母列 log.info(CharSetUtils.delete(memo,&quot;a-c&quot;)); //仅保留指定字母列 log.info(CharSetUtils.keep(memo,&quot;c-z&quot;)); //删除重复值 log.info(CharSetUtils.squeeze(memo, &quot;l&quot;)); //计算指定字母数 log.info(CharSetUtils.count(memo, &quot;l&quot;)); }} 结果 12345672016-07-23 14:41:34 [INFO] true [main] com.xudalong.CharSetUtils.TestCharSetUtils [com.xudalong.CharSetUtils.TestCharSetUtils.TestCharSet(TestCharSetUtils.java:27)]2016-07-23 14:41:34 [INFO] xudollong [main] com.xudalong.CharSetUtils.TestCharSetUtils [com.xudalong.CharSetUtils.TestCharSetUtils.TestCharSet(TestCharSetUtils.java:29)]2016-07-23 14:41:34 [INFO] xudollong [main] com.xudalong.CharSetUtils.TestCharSetUtils [com.xudalong.CharSetUtils.TestCharSetUtils.TestCharSet(TestCharSetUtils.java:31)]2016-07-23 14:41:34 [INFO] xudaolong [main] com.xudalong.CharSetUtils.TestCharSetUtils [com.xudalong.CharSetUtils.TestCharSetUtils.TestCharSet(TestCharSetUtils.java:33)]2016-07-23 14:41:34 [INFO] 2 [main] com.xudalong.CharSetUtils.TestCharSetUtils [com.xudalong.CharSetUtils.TestCharSetUtils.TestCharSet(TestCharSetUtils.java:35)]","link":"/2016/09/11/apache-common/java-common-Lang-CharSetUtils/"},{"title":"git 指令大全","text":"查看已有的ssh ls -al ~/.ssh 生成ssh,可设置密码 ssh-keygen -t rsa -b 4096 -C “xudaolong@vip.qq.com“ 添加到ssh-agent代理,检测 eval “$(ssh-agent -s)” 添加到指定的代理 $ ssh-add ~/.ssh/id_rsa 复制.pub的数据到指定的key提交暂存区到仓库区 $ git commit -m [message] 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 提交时显示所有diff信息 $ git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化 $ git commit –amend [file1] [file2] … 列出所有本地分支 $ git branch 列出所有远程分支 $ git branch -r 列出所有本地分支和远程分支 $ git branch -a 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 新建一个分支，并切换到该分支 $ git checkout -b [branch] 新建一个分支，指向指定commit $ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 $ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区 $ git checkout [branch-name] 切换到上一个分支 $ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支 $ git merge [branch] 选择一个commit，合并进当前分支 $ git cherry-pick [commit] 删除分支 $ git branch -d [branch-name] 删除远程分支 $ git push origin –delete [branch-name]$ git branch -dr [remote/branch] 生成一个可供发布的压缩包 $ git archive 添加指定文件到暂存区 $ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录 $ git add [dir] 添加当前目录的所有文件到暂存区 $ git add . 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交 $ git add -p 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区 $ git rm –cached [file] 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] Webstorm 自动生成 12345678910111213141516171819202122232425262728293031323334353637&gt; Logslogs*.lognpm-debug.log*&gt; Runtime datapids*.pid*.seed&gt; Directory for instrumented libs generated by jscoverage/JSCoverlib-cov&gt; Coverage directory used by tools like istanbulcoverage&gt; nyc test coverage.nyc_output&gt; Grunt intermediate storage (http://gruntjs.com/creating-plugins&gt;storing-task-files).grunt&gt; node-waf configuration.lock-wscript&gt; Compiled binary addons (http://nodejs.org/api/addons.html)build/Release&gt; Dependency directoriesnode_modulesjspm_packages&gt; Optional npm cache directory.npm&gt; Optional REPL history.node_repl_history 恢复暂存区的指定文件到工作区 $ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 恢复暂存区的所有文件到工作区 $ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 重置暂存区与工作区，与上一次commit保持一致 $ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset –keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash$ git stash pop 在当前目录新建一个Git代码库 $ git init 新建一个目录，将其初始化为Git代码库 $ git init [project-name] 下载一个项目和它的整个代码历史 $ git clone [url] 显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log 显示commit历史，以及每次commit发生变更的文件 $ git log –stat 搜索提交历史，根据关键词 $ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD –grep feature 显示某个文件的版本历史，包括文件改名 $ git log –follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff $ git log -p [file] 显示过去5次提交 $ git log -5 –pretty –oneline 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 显示指定文件是什么人在什么时间修改过 $ git blame [file] 显示暂存区和工作区的差异 $ git diff 显示暂存区和上一个commit的差异 $ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 显示两次提交之间的差异 $ git diff [first-branch]…[second-branch] 显示今天你写了多少行代码 $ git diff –shortstat “@{0 day ago}” 显示某次提交的元数据和内容变化 $ git show [commit] 显示某次提交发生变化的文件 $ git show –name-only [commit] 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 显示当前分支的最近几次提交 $ git reflog 列出所有tag $ git tag 新建一个tag在当前commit $ git tag [tag] 新建一个tag在指定commit $ git tag [tag] [commit] 删除本地tag $ git tag -d [tag] 删除远程tag $ git push origin :refs/tags/[tagName] 查看tag信息 $ git show [tag] 提交指定tag $ git push [remote] [tag] 提交所有tag $ git push [remote] –tags 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 下载远程仓库的所有变动 $ git fetch [remote] 显示所有远程仓库 $ git remote -v 显示某个远程仓库的信息 $ git remote show [remote] 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] –force 推送所有分支到远程仓库 $ git push [remote] –all 显示当前的Git配置 $ git config –list 编辑Git配置文件 $ git config -e [–global] 设置提交代码时的用户信息 $ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]”","link":"/2016/09/11/git/git%20%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"intellj-idea-开发环境配置","text":"忽略大小写 显示行号 版权控制","link":"/2016/09/11/intellj-idea/intellj-idea-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"intellj-idea-maven-Web项目-+-tomcat-的搭建","text":"新入职公司,对公司内部的系统进行搭建,在此进行记录 思路如下 导入 maven 项目 相关的jar 包--&gt;关联相关的框架 --&gt; 配置tomcat 的处理 导入项目,选择maven框架,一直点next 进入之后更新jar包,和导入必要的包 然后添加相关联的框架,如Spring 配置tomcat 点开项目结构,依次步骤","link":"/2016/09/11/intellj-idea/intellj-idea-maven-Web%E9%A1%B9%E7%9B%AE-+-tomcat-%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"title":"js-Set-简介","text":"不含相同元素,但是不提供索引 has()的速度快过 indexOf() 创建new Set() 长度set.size 查询set.has() set.keys()、set.values()和set.entries() 操作,返回集合本身.add() .delete() .clear() 迭代器for of //in 没有效果","link":"/2016/09/11/Javascript/js-Set-%E7%AE%80%E4%BB%8B/"},{"title":"js-IIFE--立即调用的函数表达式","text":"1234567891011121314151617181.(function(){// do something })();2.[function(){// do something }()];3.(function(){// do something }());4.!function(){ // do something }();5.~ function() {}();6.+ function() {}();7.- function() {}()8.delete function() {}();9.typeof function() {}();10.void function() {}();11.new function() {}();12.new function() {};13.var f = function() {}();14.1, function() {}();15.1 ^ function() {}();16.1 &gt; function() {}();","link":"/2016/09/11/Javascript/js-IIFE--%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"js-Symbol-介绍及应用","text":"应用场景 123451.Symbol()--&gt;解决属性名的冲突,因为传入对象属性时,同样的Symbol不相等;解释:什么是冲突呢？当多人合作编码的时候，经常会出现你往对象上加了一个某某属性（比如 $ ），他人正好也想到了这个名称，当你们同时用了这个名称作为属性，代码之间就会发生冲突，互相覆盖。而用 symbol，即使都用了相同的描述，也不是同一个 symbol。2.Symbol.for()--&gt;共享Symbol,因为返回值得不一样,keyFor()用来查看它的描述 新的基本类型 null,underfined,number,boolean,string,object 基本判断 typeof Symbol() === 'symbol' 特点 12341.Symbol('key') !== Symbol('key') //true,返回不同2.Symbol(&quot;know&quot;).name = 1; // TypeError,只读3.for...in 、 Object.keys(obj) 、Object.getOwnPropertyNames(obj)会忽略Symbol,即自身不可枚举4.不能用obj.prop的形式访问 创建 1234567var obj = { a: 1};var safeKey = Symbol(&quot;know&quot;);console.log(safeKey);//Symbol(know)obj[safeKey] = 'value';console.log(obj[safeKey]); // value 查询 121.Object.getOwnPropertySymbols(obj) //获取Symbol属性名,但是也会忽略内置的Symbol2.Reflect.ownKeys(obj)//获取所有的属性名 js.Symbol 代替1234567let obj = { [Symbol.replace](string) { console.log(string); return &quot;replllll&quot;; }};console.log( &quot;sssss&quot;.replace(obj) ); //输出： sssss replllll js.Symbol 迭代器js.Symbol 迭代器 Symbol.Iterator：对象的Symbol.Iterator属性， 指向这个对象的默认遍历器： 1234567var myIterable = {};myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3;};console.log([...myIterable]); // [1, 2, 3] js.Symbol 私有属性12345678910111213141516171819202122232425262728var Person = (function() { let _name = Symbol(); class Person { constructor(name) { this[_name] = name; } get name() { return this[_name]; } } return Person;})();//es5简单代替方法,但是查看属性名的时候会发现垃圾字符串var Person = (function() { var _name = &quot;00&quot; + Math.random(); function Person(name) { this[_name] = name; } Object.defineProperty(Person.prototype, &quot;name&quot;, { get: function() { return this[_name]; } }); return Person;})();","link":"/2016/09/11/Javascript/js-Symbol-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"title":"js-es6-对象解构赋值","text":"best 例子 123function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`;} 注意返回来的时候是对象而不是数组 12345678// good function processInput(input) { // then a miracle occurs return { left, right, top, bottom }; } // 调用时只选择需要的数据 const { left, right } = processInput(input); 对象属性的覆盖 12345678910var robotA = { name: &quot;Bender&quot; };var robotB = { name: &quot;Flexo&quot; };var { name: nameA } = robotA;var { name: nameB } = robotB;console.log(nameA);// &quot;Bender&quot;console.log(nameB);// &quot;Flexo&quot; 避免判断是否存在的情况 123456789101112jQuery.ajax = function (url, { async = true, beforeSend = noop, cache = true, complete = noop, crossDomain = false, global = , // ... more config}) { // ... do stuff}; 与迭代器一起使用 1234567891011121314151617var map = new Map();map.set(window, &quot;the global&quot;);map.set(document, &quot;the document&quot;);for (var [key, value] of map) { console.log(key + &quot; is &quot; + value);}// &quot;[object Window] is the global&quot;// &quot;[object HTMLDocument] is the document&quot;for (var [key] of map) { // ...}for (var [,value] of map) { // ...} 返回多值 1234567function returnMultipleValues() { return { foo: 3, bar: 4 };}var demo = { foo, bar } = returnMultipleValues(); 导入 CommonJS 模块的指定部分 1const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);","link":"/2016/09/11/Javascript/js-es6-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"js-Reflect","text":"js.Reflect http://www.cnblogs.com/diligenceday/p/5474126.html Object.defineProperty(obj, name, desc)执行成功会返回obj， 以及其它原因导致的错误 Reflect.defineProperty只会返回false或者true来表示对象的属性是否设置上了 12345if (Reflect.defineProperty(obj, name, desc)) { // success} else { // failure} 其余的方法， 比如Relect.set ， Reflect.deleteProperty, Reflect.preventExtensions, &gt;Reflect.setPrototypeOf， 都可以进行重构； js.Reflect get123456789101112var Reflect = require('harmony-reflect');var obj = { &quot;foo&quot; : 1, get bar() { return this.foo; }};var foo = {};foo.foo = &quot;heheda&quot;;console.log(Reflect.get(obj, &quot;bar&quot;, foo)); js.Reflect 函数操作 如果要判断一个obj有定义或者继承了属性name， 在ES5中这样判断：name in obj ； 或者删除一个属性 ：&gt; delete obj[name], 虽然这些很好用， 很简短， 很明确， 但是要使用的时候也要封装成一个类； 有了Reflect， 它帮你封装好了， Reflect.has(obj, name), Reflect.deleteProperty(obj, name); js.Reflect 可变参数的构造函数 演变过程 123var obj = new F(...args)var obj = Reflect.construct(F, args) js.Reflect 可靠的函数式执行方式12345678910# 演变过程f.apply(obj, args)# 避免被重新定义Function.prototype.apply.call(f, obj, args)# 更加简明Reflect.apply(f, obj, args)","link":"/2016/09/11/Javascript/js-Reflect/"},{"title":"js-&amp;&amp;-和----用法","text":"a() &amp;&amp; b() :如果执行a()后返回true，则执行b()并返回b的值；如果执行a()后返回false，则整个表达式返回a()的值，b()不执行；a() || b() :如果执行a()后返回true，则整个表达式返回a()的值，b()不执行；如果执行a()后返回false，则执行b()并返回b()的值；&amp;&amp; 优先级高于 || 如下代码: 123alert((1 &amp;&amp; 3 || 0) &amp;&amp; 4); //结果4 ①alert(1 &amp;&amp; 3 || 0 &amp;&amp; 4); //结果3 ②alert(0 &amp;&amp; 3 || 1 &amp;&amp; 4); //结果4 ③ 分析： 1234语句①：1&amp;&amp;3 返回3 =&gt; 3 || 0 返回 3 =&gt; 3&amp;&amp;4 返回 4语句②：先执行1&amp;&amp;3 返回3，在执行0&amp;&amp;4返回0，最后执行结果比较 3||0 返回 3语句③：先执行0&amp;&amp;3 返回0，在执行1&amp;&amp;4返回4，最后执行结果比较 0||4 返回 4注：非0的整数都为true，undefined、null和空字符串”&quot; 为false。","link":"/2016/09/11/Javascript/js-&&-%E5%92%8C----%E7%94%A8%E6%B3%95/"},{"title":"js-es6-数组解构赋值","text":"捕获剩余项 123var [head, ...tail] = [1, 2, 3, 4];console.log(tail);// [2, 3, 4] 在生成器的作用 1234567891011function* fibs() { var a = 0; var b = 1; while (true) { yield a; [a, b] = [b, a + b]; }}var [first, second, third, fourth, fifth, sixth] = fibs();console.log(sixth);","link":"/2016/09/11/Javascript/js-es6-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"js-export","text":"1234export { myFunction }; // 导出一个函数声明export const foo = Math.sqrt(2); // 导出一个常量export default myFunctionOrClass 使用 12345// module &quot;my-module.js&quot;let cube = function cube(x) { return x * x * x;}export default cube;","link":"/2016/09/11/Javascript/js-export/"},{"title":"js-module-多种模式的开发","text":"AMD 12345678910define(function(require, exports, module) { var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... exports.action = function() {};}) CommonJS 1234567891011121314151617exports.firstName = 'mei';exports.lastName = 'qingguang';exports.year = 1988;// ormodule.exports = { firstName: 'mei', lastName: 'qingguang', year: 1988}// ormodule.exports = function() { // do something}","link":"/2016/09/11/Javascript/js-module-%E5%A4%9A%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%8F%91/"},{"title":"js-数据属性和访问器属性","text":"数据属性 数据的获取与设置 12345678Value:undefined,writable:false,enumerable:false,configurable:false;","link":"/2016/09/11/Javascript/js-%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/"},{"title":"js-时间--测试函数","text":"1234567function cal_fn_time(fn) { var timebegin = (new Date()).getTime(); console.log(for_iphone); fn(); var timeend = (new Date()).getTime(); return (timeend - timebegin)/1000 + &quot;s&quot;;}","link":"/2016/09/11/Javascript/js-%E6%97%B6%E9%97%B4--%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/"},{"title":"java-castor-与XML的数据绑定","text":"为什么使用XML的格式?主要因为XML的约定的语法比较丰富,比JSON中仅含的Object和Array. 关于Castor 另附 Java ORM/持久层框架https://www.oschina.net/project/tag/126/orm?sort=view&amp;lang=19&amp;os=36 参考资源https://castor-data-binding.github.io/castor/reference-guide/reference/xml/xml-properties.htmlhttp://www.ibm.com/developerworks/cn/xml/x-bindcastor/http://blog.csdn.net/p385579058/article/details/8237441","link":"/2016/09/11/java/java-castor-%E4%B8%8EXML%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"title":"js-管理私有属性","text":"12345678910111213class Countdown { constructor(counter, action) { Object.assign(this, { dec() { if (counter &lt; 1) return; counter--; if (counter === 0) { action(); } } }); }} 优点： 私有数据非常安全；私有属性的命名不会与其他父类或子类的私有属性命名冲突。缺点： 当你需要在构造函数内把所有方法（至少那些需要用到私有数据的方法）添加到实例的时候，代码看起来就没那么优雅了；作为实例方法，代码会浪费内存；如果作为原型方法，则会被共享。 12345678910111213class Countdown { constructor(counter, action) { this._counter = counter; this._action = action; } dec() { if (this._counter &lt; 1) return; this._counter--; if (this._counter === 0) { this._action(); } }} 优点： 代码比较美观；可以使用原型方法。缺点： 不够安全，只能用规范去约束用户代码；私有属性的命名容易冲突。 1234567891011121314151617let _counter = new WeakMap();let _action = new WeakMap();class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) { _action.get(this)(); } }} 优点： 可以使用原型方法；比属性命名约定更加安全；私有属性命名不会冲突。Con: 代码不如命名约定优雅。 12345678910111213141516const _counter = Symbol('counter');const _action = Symbol('action');class Countdown { constructor(counter, action) { this[_counter] = counter; this[_action] = action; } dec() { if (this[_counter] &lt; 1) return; this[_counter]--; if (this[_counter] === 0) { this[_action](); } }} 优点： 可以使用原型方法；私有属性命名不会冲突。缺点： 代码不如命名约定优雅；不太安全：可以通过 Reflect.ownKeys() 列出一个对象所有的属性键名（即使用了 Symbol）。","link":"/2016/09/11/Javascript/js-%E7%AE%A1%E7%90%86%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"title":"js-闭包理解---缺乏形参","text":"12345for (var i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i); }, i*1000);} 解释原因 var i，实际上声明了一个全局变量 延迟函数timer必然是在循环结束后才开始执行，循环结束后，i＝6 循环中确实定义了多个延迟函数timer，延迟函数在setTimeout的内部被回调，根据闭包概念，timer在其声明之外的地方被调用，timer能够记住并访问其声明位置的词法作用域，存在闭包 实际上timer所记住的词法作用域就是全局作用域，所以引用输出的i都是6 修改方案 只要能保证每次循环都能够创建新的作用域，在新作用域中保存当前i的值即可 所以任何可以创建新作用域的方法都可以达到效果，具体可参考这里， 通过分析这段代码的进化历程，或许能够加深您对JavaScript的作用域的理解 常见的做法有 利用具名立即执行函数，每次循环都创建新作用域 1234567for (var i = 1; i &lt;= 5; i++) { (function scope(j) { setTimeout(function timer() { console.log(j); }, i * 1000); })(i);} 利用es6 let创建块作用域 12345678for (var i = 1; i &lt;= 5; i++) { { let j = i; setTimeout(function timer() { console.log(j); }, i * 1000); }} 总结:根据闭包的概念，只要有回调就会有闭包","link":"/2016/09/11/Javascript/js-%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3---%E7%BC%BA%E4%B9%8F%E5%BD%A2%E5%8F%82/"},{"title":"js-类型的转换","text":"转成字符串 12// goodconst totalScore = String(this.reviewScore); 转成数字 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 转成布尔 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// goodconst hasAge = !!age;","link":"/2016/09/11/Javascript/js-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"title":"js-对象简写","text":"函数简写 12345678// goodconst atom = { value: 1, addValue(value) { return atom.value + value; },}; 属性简写 1234567891011const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// goodconst obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,};","link":"/2016/09/11/Javascript/js-%E5%AF%B9%E8%B1%A1%E7%AE%80%E5%86%99/"},{"title":"java-fastjson-解析json配置文件","text":"需要准备下面工具: 12345fastjsoncommon-io(文件转化为Stirng)网址:http://www.bejson.com/json2javapojo/ (JSON字符串转换成Java实体类(POJO)) json格式如下 1234567891011121314151617{ &quot;QRratio&quot;: { &quot;x&quot;: 111, &quot;y&quot;: 111, &quot;width&quot;: 4000, &quot;height&quot;: 4000 }, &quot;Interleaved2of5&quot;: { &quot;x&quot;: 111, &quot;y&quot;: 111, &quot;width&quot;: 4000, &quot;height&quot;: 4000 }, &quot;comment&quot;: &quot;不同分辨率的情况下获取的区域不一样&quot;} 生成Java实体类 核心代码块 123456//配置不同分辨率下不同的QR 和 25 码的配置文件InputStream inputStream = new FileInputStream(&quot;config/billtype.conf.json&quot;);String text = IOUtils.toString(inputStream,&quot;utf8&quot;);Root root = JSON.parseObject(text,Root.class); 导包 12345678import com.alibaba.fastjson.JSON;import com.xudaolong.bean.config.Root;import org.apache.commons.io.IOUtils;import java.io.File;import java.io.FileInputStream;","link":"/2016/09/11/java/java-fastjson-%E8%A7%A3%E6%9E%90json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"title":"java-图片切割","text":"工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360package com.xudaolong.Utils;import javax.imageio.IIOImage;import javax.imageio.ImageIO;import javax.imageio.ImageReader;import javax.imageio.ImageWriter;import javax.imageio.stream.ImageInputStream;import javax.imageio.stream.ImageOutputStream;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.util.Arrays;import java.util.Iterator;/** * 图像裁剪以及压缩处理工具类 * &lt;p&gt; * 主要针对动态的GIF格式图片裁剪之后，只出现一帧动态效果的现象提供解决方案 * &lt;p&gt; * 提供依赖三方包解决方案（针对GIF格式数据特征一一解析，进行编码解码操作） * 提供基于JDK Image I/O 的解决方案(JDK探索失败) */public class ImageCutterUtil { public enum IMAGE_FORMAT { BMP(&quot;bmp&quot;), JPG(&quot;jpg&quot;), WBMP(&quot;wbmp&quot;), JPEG(&quot;jpeg&quot;), PNG(&quot;png&quot;), GIF(&quot;gif&quot;); private String value; IMAGE_FORMAT(String value) { this.value = value; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } /** * 获取图片格式 * * @param file 图片文件 * @return 图片格式 */ public static String getImageFormatName(File file) throws IOException { String formatName = null; ImageInputStream iis = ImageIO.createImageInputStream(file); Iterator&lt;ImageReader&gt; imageReader = ImageIO.getImageReaders(iis); if (imageReader.hasNext()) { ImageReader reader = imageReader.next(); formatName = reader.getFormatName(); } return formatName; } /*********************** 基于JDK 解决方案 ********************************/ /** * 读取图片 * * @param file 图片文件 * @return 图片数据 * @throws IOException */ public static BufferedImage[] readerImage(File file) throws IOException { BufferedImage sourceImage = ImageIO.read(file); BufferedImage[] images = null; ImageInputStream iis = ImageIO.createImageInputStream(file); Iterator&lt;ImageReader&gt; imageReaders = ImageIO.getImageReaders(iis); if (imageReaders.hasNext()) { ImageReader reader = imageReaders.next(); reader.setInput(iis); int imageNumber = reader.getNumImages(true); images = new BufferedImage[imageNumber]; for (int i = 0; i &lt; imageNumber; i++) { BufferedImage image = reader.read(i); if (sourceImage.getWidth() &gt; image.getWidth() || sourceImage.getHeight() &gt; image.getHeight()) { image = zoom(image, sourceImage.getWidth(), sourceImage.getHeight()); } images[i] = image; } reader.dispose(); iis.close(); } return images; } /** * 根据要求处理图片 * * @param images 图片数组 * @param x 横向起始位置 * @param y 纵向起始位置 * @param width 宽度 * @param height 宽度 * @return 处理后的图片数组 * @throws Exception */ public static BufferedImage[] processImage(BufferedImage[] images, int x, int y, int width, int height) throws Exception { if (null == images) { return images; } BufferedImage[] oldImages = images; images = new BufferedImage[images.length]; for (int i = 0; i &lt; oldImages.length; i++) { BufferedImage image = oldImages[i]; images[i] = image.getSubimage(x, y, width, height); } return images; } /** * 写入处理后的图片到file * &lt;p&gt; * 图片后缀根据图片格式生成 * * @param images 处理后的图片数据 * @param formatName 图片格式 * @param file 写入文件对象 * @throws Exception */ public static void writerImage(BufferedImage[] images, String formatName, File file) throws Exception { Iterator&lt;ImageWriter&gt; imageWriters = ImageIO.getImageWritersByFormatName(formatName); if (imageWriters.hasNext()) { ImageWriter writer = imageWriters.next(); String fileName = file.getName(); int index = fileName.lastIndexOf(&quot;.&quot;); if (index &gt; 0) { fileName = fileName.substring(0, index + 1) + formatName; } String pathPrefix = getFilePrefixPath(file.getPath()); File outFile = new File(pathPrefix + fileName); ImageOutputStream ios = ImageIO.createImageOutputStream(outFile); writer.setOutput(ios); if (writer.canWriteSequence()) { writer.prepareWriteSequence(null); for (int i = 0; i &lt; images.length; i++) { BufferedImage childImage = images[i]; IIOImage image = new IIOImage(childImage, null, null); writer.writeToSequence(image, null); } writer.endWriteSequence(); } else { for (int i = 0; i &lt; images.length; i++) { writer.write(images[i]); } } writer.dispose(); ios.close(); } } /** * 剪切格式图片 * &lt;p&gt; * 基于JDK Image I/O解决方案 * * @param sourceFile 待剪切图片文件对象 * @param destFile 裁剪后保存文件对象 * @param x 剪切横向起始位置 * @param y 剪切纵向起始位置 * @param width 剪切宽度 * @param height 剪切宽度 * @throws Exception */ public static void cutImage(File sourceFile, File destFile, int x, int y, int width, int height) throws Exception { // 读取图片信息 BufferedImage[] images = readerImage(sourceFile); // 处理图片 images = processImage(images, x, y, width, height); // 获取文件后缀 String formatName = getImageFormatName(sourceFile); destFile = new File(getPathWithoutSuffix(destFile.getPath()) + formatName); // 写入处理后的图片到文件 writerImage(images, formatName, destFile); } /** * 获取系统支持的图片格式 */ public static void getOSSupportsStandardImageFormat() { String[] readerFormatName = ImageIO.getReaderFormatNames(); String[] readerSuffixName = ImageIO.getReaderFileSuffixes(); String[] readerMIMEType = ImageIO.getReaderMIMETypes(); System.out.println(&quot;========================= OS supports reader ========================&quot;); System.out.println(&quot;OS supports reader format name : &quot; + Arrays.asList(readerFormatName)); System.out.println(&quot;OS supports reader suffix name : &quot; + Arrays.asList(readerSuffixName)); System.out.println(&quot;OS supports reader MIME type : &quot; + Arrays.asList(readerMIMEType)); String[] writerFormatName = ImageIO.getWriterFormatNames(); String[] writerSuffixName = ImageIO.getWriterFileSuffixes(); String[] writerMIMEType = ImageIO.getWriterMIMETypes(); System.out.println(&quot;========================= OS supports writer ========================&quot;); System.out.println(&quot;OS supports writer format name : &quot; + Arrays.asList(writerFormatName)); System.out.println(&quot;OS supports writer suffix name : &quot; + Arrays.asList(writerSuffixName)); System.out.println(&quot;OS supports writer MIME type : &quot; + Arrays.asList(writerMIMEType)); } /** * 压缩图片 * * @param sourceImage 待压缩图片 * @param width 压缩图片高度 * @param height 压缩图片宽度 */ private static BufferedImage zoom(BufferedImage sourceImage, int width, int height) { BufferedImage zoomImage = new BufferedImage(width, height, sourceImage.getType()); Image image = sourceImage.getScaledInstance(width, height, Image.SCALE_SMOOTH); Graphics gc = zoomImage.getGraphics(); gc.setColor(Color.WHITE); gc.drawImage(image, 0, 0, null); return zoomImage; } /** * 获取某个文件的前缀路径 * &lt;p&gt; * 不包含文件名的路径 * * @param file 当前文件对象 * @return * @throws IOException */ public static String getFilePrefixPath(File file) throws IOException { String path = null; if (!file.exists()) { throw new IOException(&quot;not found the file !&quot;); } String fileName = file.getName(); path = file.getPath().replace(fileName, &quot;&quot;); return path; } /** * 获取某个文件的前缀路径 * &lt;p&gt; * 不包含文件名的路径 * * @param path 当前文件路径 * @return 不包含文件名的路径 * @throws Exception */ public static String getFilePrefixPath(String path) throws Exception { if (null == path || path.isEmpty()) throw new Exception(&quot;文件路径为空！&quot;); int index = path.lastIndexOf(File.separator); if (index &gt; 0) { path = path.substring(0, index + 1); } return path; } /** * 获取不包含后缀的文件路径 * * @param src * @return */ public static String getPathWithoutSuffix(String src) { String path = src; int index = path.lastIndexOf(&quot;.&quot;); if (index &gt; 0) { path = path.substring(0, index + 1); } return path; } /** * 获取文件名 * * @param filePath 文件路径 * @return 文件名 * @throws IOException */ public static String getFileName(String filePath) throws IOException { File file = new File(filePath); if (!file.exists()) { throw new IOException(&quot;not found the file !&quot;); } return file.getName(); } /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception { // 获取系统支持的图片格式// ImageCutterUtil.getOSSupportsStandardImageFormat(); try { // 起始坐标，剪切大小 int x = 14; int y = 24; int width = 62; int height = 62; // 参考图像大小 int clientWidth = 88; int clientHeight = 88; File file = new File(&quot;/Users/mac/IdeaProjects/QRdemo/resources/src/com/xudaolong/QR/TestQR/QR.jpg&quot;); BufferedImage image = ImageIO.read(file); double destWidth = image.getWidth(); double destHeight = image.getHeight(); if (destWidth &lt; width || destHeight &lt; height) throw new Exception(&quot;源图大小小于截取图片大小!&quot;); double widthRatio = destWidth / clientWidth; double heightRatio = destHeight / clientHeight; x = Double.valueOf(x * widthRatio).intValue(); y = Double.valueOf(y * heightRatio).intValue(); width = Double.valueOf(width * widthRatio).intValue(); height = Double.valueOf(height * heightRatio).intValue(); System.out.println(&quot;裁剪大小 x:&quot; + x + &quot;,y:&quot; + y + &quot;,width:&quot; + width + &quot;,height:&quot; + height); String formatName = getImageFormatName(file); String pathSuffix = &quot;.&quot; + formatName; String pathPrefix = getFilePrefixPath(file); String targetPath = pathPrefix + System.currentTimeMillis() + pathSuffix; File destFile = new File(targetPath); ImageCutterUtil.cutImage(file, destFile, x, y, width, height); } catch (IOException e) { e.printStackTrace(); } }} 单方面测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public void cutQR(String sourcePath) { try { File file = new File(sourcePath); BufferedImage image = ImageIO.read(file); // 起始坐标，剪切大小 int x = 14; int y = 25; int width = 62; int height = 62; // 参考图像大小 int clientWidth = 88; int clientHeight = 88; double destWidth = image.getWidth(); double destHeight = image.getHeight(); if (destWidth &lt; width || destHeight &lt; height) throw new Exception(&quot;源图大小小于截取图片大小!&quot;); double widthRatio = destWidth / clientWidth; double heightRatio = destHeight / clientHeight; //修改一下单位 x = Double.valueOf(x * widthRatio).intValue(); y = Double.valueOf(y * heightRatio).intValue(); width = Double.valueOf(width * widthRatio).intValue(); height = Double.valueOf(height * heightRatio).intValue(); System.out.println(&quot;裁剪大小 x:&quot; + x + &quot;,y:&quot; + y + &quot;,width:&quot; + width + &quot;,height:&quot; + height); //获取指定的名字// String formatName = getImageFormatName(file);// String pathSuffix = &quot;.&quot; + formatName;// String pathPrefix = getFilePrefixPath(file);// String targetPath = pathPrefix + System.currentTimeMillis() + pathSuffix; //最后一步进行裁剪到指定的名字 File destFile = new File(sourcePath); ImageCutterUtil.cutImage(file, destFile, x, y, width, height); } catch (Exception e) { e.printStackTrace(); } }","link":"/2016/09/11/java/java-%E5%9B%BE%E7%89%87%E5%88%87%E5%89%B2/"},{"title":"java-获取当前文件-class-的相对或绝对路径","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.xudaolong.Utils;import java.io.File;/** * Created by xudaolong on 16/7/12. */public class Path { private static final String TAG = &quot;Path&quot;; /** * 创建不存在的目录 * @param c * @param dir * @return */ public File rebuildDir(Class c,File dir){ for (String s : c.getName().split(&quot;\\\\.&quot;)) { dir = new File(dir, s); if (dir.isDirectory() == false) dir.mkdirs(); } return dir; } /** * 返回指定的路径为 resources * * @param c * @return */ public String getDataDir(Class c) { //获取当前的路径 File dir = new File(System.getProperty(&quot;user.dir&quot;)); //目录resolve dir = new File(dir, &quot;resources&quot;); dir = this.rebuildDir(c, dir); System.out.println(TAG + &quot;::Using data directory::&quot; + dir.toString()); return dir.toString() + File.separator; } /** * 返回指定相对路径,相对的是user.dir * @param c * @param desc * @return */ public String getDataDir(Class c, String desc) { //获取当前的路径 File dir = new File(System.getProperty(&quot;user.dir&quot;)); //目录resolve dir = new File(dir, desc); dir = this.rebuildDir(c, dir); System.out.println(TAG + &quot;::Using data directory::&quot; + dir.toString()); return dir.toString() + File.separator; }}","link":"/2016/09/11/java/java-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6-class-%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%88%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"},{"title":"js-array-api-常用","text":"function:Array.from 函数从类似数组的对象或可迭代的对象返回一个数组。 1234var arr = Array.from([1, 2, 3], x =&gt; x * 10);// arr[0] == 10;// arr[1] == 20;// arr[2] == 30; Array.isArray 函数返回一个布尔值，该值指示对象是否为数组。 Array.of 函数从传入的参数返回一个数组。 12var arr = Array.of(1, 2, 3);// arr[0] == 1 concat 方法（数组）返回由两个数组组合而成的新数组。 entries 方法 keys values返回包含数组的键/值对的迭代器。 1234var entries = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries();// entries.next().value == [0, &quot;a&quot;]// entries.next().value == [1, &quot;b&quot;]// entries.next().value == [2, &quot;c&quot;] every 方法检查定义的回调函数是否为数组中的所有元素返回 true。 12345678910111213141516171819202122// Define the callback function.function CheckIfEven(value, index, ar) { document.write(value + &quot; &quot;); if (value % 2 == 0) return true; else return false;}// Create an array.var numbers = [2, 4, 5, 6, 8];// Check whether the callback function returns true for all of the// array values.if (numbers.every(CheckIfEven)) document.write(&quot;All are even.&quot;);else document.write(&quot;Some are not even.&quot;);// Output:// 2 4 5 Some are not even. fill 方法使用指定值填充数组。 filter 方法对数组的每个元素调用定义的回调函数，并返回回调函数为其返回 true 的值的数组。 findIndex 方法返回满足回调函数中指定的测试条件的第一个数组元素的索引值。 forEach 方法为数组中的每个元素调用定义的回调函数。 hasOwnProperty 方法返回一个布尔值，该值指示某个对象是否具有指定名称的属性。 indexOf 方法（数组）返回某个值在数组中的第一个匹配项的索引。 isPrototypeOf 方法返回一个布尔值，该值指示某个对象是否存在于另一个对象的原型链中。 join 方法返回由一个数组的所有元素串联而成的 String 对象。 keys 方法返回包含数组的索引值的迭代器。 lastIndexOf 方法（数组）返回指定值在数组中的最后一个匹配项的索引。 map 方法对数组的每个元素调用定义的回调函数并返回包含结果的数组。 pop 方法从数组中移除最后一个元素并将该元素返回。 propertyIsEnumerable 方法返回一个布尔值，该值指示指定属性是否为对象的一部分且是否可枚举。 push 方法将新元素追加到一个数组中，并返回数组的新长度。 reduce 方法通过对数组中的所有元素调用定义的回调函数来累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供。 reduceRight 方法通过对数组中的所有元素调用定义的回调函数来按降序顺序累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供。 reverse 方法将元素顺序被反转的 Array 对象返回。 shift 方法从数组中移除第一个元素并将返回该元素。 slice 方法（数组）返回一个数组中的一部分。 some 方法检查定义的回调函数是否为数组的任何元素返回 true。 sort 方法返回一个元素已经进行了排序的 Array 对象。 splice 方法从一个数组中移除元素，如有必要，在所移除元素的位置上插入新元素，并返回所移除的元素。 toLocaleString 方法返回使用当前区域设置的字符串。 toString 方法返回数组的字符串表示形式。 unshift 方法在数组的开头插入新元素。 valueOf 方法获取对数组的引用。 values 方法返回包含数组的值的迭代器。","link":"/2016/09/11/Javascript-array/js-array-api-%E5%B8%B8%E7%94%A8/"},{"title":"js-array-Array-of-转换数组","text":"123456789101112Array.of()// &lt;- []Array.of(undefined)// &lt;- [undefined]Array.of(1)// &lt;- [1]Array.of(3)// &lt;- [3]Array.of(1, 2)// &lt;- [1, 2]Array.of(-1)// &lt;- [-1]","link":"/2016/09/11/Javascript-array/js-array-Array-of-%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%84/"},{"title":"js-array-reduce","text":"返回值是积累的结果12345678910111213141516171819202122232425 // good let sum = 0; numbers.forEach((num) =&gt; sum += num); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) =&gt; total + num, 0); sum === 15;// Define the callback function.function appendCurrent (previousValue, currentValue) { return previousValue + &quot;::&quot; + currentValue; }// Create an array.var elements = [&quot;abc&quot;, &quot;def&quot;, 123, 456];// Call the reduce method, which calls the callback function// for each array element.var result = elements.reduce(appendCurrent);document.write(result);// Output:// abc::def::123::456","link":"/2016/09/11/Javascript-array/js-array-reduce/"},{"title":"js-array-复制数组","text":"避免用遍历,类似map等能生成新的数组的就是了… 12// goodconst itemsCopy = [...items]; 类数组的转换成数组 1const nodes = Array.from();","link":"/2016/09/11/Javascript-array/js-array-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84/"},{"title":"js-array-生成数组","text":"第一种 12345function cast () { return [].slice.call(arguments);}cast('a','b','c','d'); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 第二种 12345678let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3}console.log(Array.from(arrayLike)); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 字符串和Set结构都具有 iterator 接口; 12345678Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]Array.from({ length: 2 }, () =&gt; 'jack') 第三种 12345function cast (){ return [...arguments]}cast('a','b','c'); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]","link":"/2016/09/11/Javascript-array/js-array-%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84/"},{"title":"js-array-填充数组","text":"一次填充 12345678['a', 'b', 'c',,,].fill(0, 2)// &lt;- ['a', 'b', 0, 0, 0]new Array(5).fill(0, 0, 3)// &lt;- [0, 0, 0, undefined x 2]new Array(3).fill({})// &lt;- [{}, {}, {}]new Array(3).fill(function foo () {})// &lt;- [function foo () {}, function foo () {}, function foo () {}] 指定填充位置 12345678910111213141516171819202122// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call({length: 5, 3: 1}, 0, 3)// {0: 1, 3: 1, length: 5}// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5]","link":"/2016/09/11/Javascript-array/js-array-%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84/"},{"title":"js-json-转换","text":"json–&gt;string 123static stringToJson(data){ return JSON.parse(data);} string–&gt;json 123static jsonToString(data){ return JSON.stringify(data);} map–&gt;json 12345678910111213141516/** *map转化为对象（map所有键都是字符串，可以将其转换为对象） */ static strMapToObj(strMap){ let obj= Object.create(null); for (let[k,v] of strMap) { obj[k] = v; } return obj; } /** *map转换为json */ static mapToJson(map) { return JSON.stringify(JsonUitl.strMapToObj(map)); } json–&gt;map 12345678910111213141516/** *map转化为对象（map所有键都是字符串，可以将其转换为对象） */ static strMapToObj(strMap){ let obj= Object.create(null); for (let[k,v] of strMap) { obj[k] = v; } return obj; } /** *map转换为json */ static mapToJson(map) { return JSON.stringify(JsonUitl.strMapToObj(map)); } map–&gt;array 12let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);&gt; [...myMap] array–&gt;map 12new Map([[true, 7], [{foo: 3}, ['abc']]])Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}","link":"/2016/09/11/Javascript-array/js-json-%E8%BD%AC%E6%8D%A2/"},{"title":"js-array-遍历数组","text":"12345for (let index of ['a', 'b'].keys()) { console.log(index);}// 0// 1 12345for (let elem of ['a', 'b'].values()) { console.log(elem);}// 'a'// 'b' 12345for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot; 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c']","link":"/2016/09/11/Javascript-array/js-array-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84/"},{"title":"js-Promise-all","text":"Promise.all(func1, func2 [,funcN])两个或两个以上,仅在所有指定承诺均完成 或者被拒绝时返回 返回承诺返回而组成的数组. 一旦其中承诺被拒绝则立刻返回拒绝承诺的原因,而其他值被丢弃","link":"/2016/09/11/Javascript-Promise/js-Promise-all/"},{"title":"js-Promise-Thenable","text":"类似Promise 具有.then 方法的对象 JQuery.ajax() 返回值就是thenable,即是jqXHR Object","link":"/2016/09/11/Javascript-Promise/js-Promise-Thenable/"},{"title":"js-Promise-catch","text":"代替catch 1234var promise = Promise.reject(new Error(&quot;message&quot;));promise.then(undefined, function (error) { console.error(error);}); ``由于 catch 标识符可能会导致问题出现，因此一些类库（Library）也采用了 caught 作为函数名，而函数要完成的工作是一样的。 而且很多压缩工具自带了将 promise.catch 转换为 promise[“catch”] 的功能， 所以可能不经意之间也能帮我们解决这个问题。 如果各位读者需要支持IE8及以下版本的浏览器的话，那么一定要将这个 catch 问题牢记在心中。``","link":"/2016/09/11/Javascript-Promise/js-Promise-catch/"},{"title":"js-Promise-race","text":"Promise.race(iterable),iterable[]–&gt;指多个Promise值 返回第一个被确认(谁快谁先上) 1234567891011121314151617// `delay`毫秒后执行resolvefunction timerPromisefy(delay) { return new Promise(function (resolve) { setTimeout(function () { resolve(delay); }, delay); });}// 任何一个promise变为resolve或reject 的话程序就停止运行Promise.race([ timerPromisefy(1000), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128)]).then(function (value) { console.log(value); // =&gt; 32}); 其他的Promise会继续运行","link":"/2016/09/11/Javascript-Promise/js-Promise-race/"},{"title":"js-Promise-resolve","text":"功能一:Promise.resolve();立即让promise进行resolve的状态,并返回Promise 相同地,Promise.reject(new Error(“出错了”)) 12345var p = Promise.resolve(233);p.then(function (v) { console.log(v);}) 功能二:将thenable 转换成 promise 1234var promise = Promise.resolve($.ajax('/json/comment.json'));// =&gt; promise对象promise.then(function(value){ console.log(value);});","link":"/2016/09/11/Javascript-Promise/js-Promise-resolve/"},{"title":"js-Promise-简介及例子","text":"用于管理与异步API交互的抽象对象,避免使用回调函数的层层嵌套 状态:等待-&gt;完成-&gt;拒绝 必须有一个then(),第一个参数是resolved,第二个是rejected函数; 实例:查询学生的信息列表，有一个文本框可以输入学生的姓名，可以进行查找指定的学生信息，如果不存在就不进行学生信息列表的查询了，如果存在，再进行下一步的查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;script type=&quot;text/javascript&quot;&gt; //判断是否存在该学生姓名 var isExistStu = function (name) { var promise = new Promise(function (resolve, reject) { $.ajax({ type: &quot;Post&quot;, url: &quot;/student/student/checkstu&quot;, dataType: &quot;json&quot;, data: JSON.stringify({ name: name }), contentType: &quot;application/json;charset-utf-8&quot;, success: function (data) { resolve(data); //data 返回来的是 true 或者 false } }); }); } //查询根据学生姓名查询学生信息列表 var searchStu = function (name) { var promise = new Promise(function (resolve, reject) { $.ajax({ type: &quot;Post&quot;, url: &quot;/student/student/getstulist&quot;, dataType: &quot;json&quot;, data: JSON.stringify({ name: name }), contentType: &quot;application/json;charset-utf-8&quot;, success: function (data) { resolve(data); //data 返回来的是学生信息列表 } }); }); } window.onload = function () { var stuName = $(&quot;txtName&quot;).val(); isExistStu(stuName).then(function (data) { if (data == &quot;true&quot;) { return searchStu(stuName); } else { return; } }).then(function (data) { showTable(data); }) } //展示 学生信息列表表格 function showTable(data) { var html = &quot;&lt;table&gt;&quot;; for (var i = 0; i &lt; data.length; i++) { html += &quot;&lt;tr&gt;&quot;; html += &quot;&lt;td&gt;&quot; + data.name + &quot;&lt;/td&gt;&quot;; html += &quot;&lt;td&gt;&quot; + data.address + &quot;&lt;/td&gt;&quot;; html += &quot;&lt;/tr&gt;&quot;; } html += &quot;&lt;/table&gt;&quot;; $(&quot;&gt;divTable&quot;).html(html); } &lt;/script&gt; function add(xPromise,yPromise) { // `Promise.all([ .. ])`接收一个Promise的数组， // 并返回一个等待它们全部完成的新Promise return Promise.all( [xPromise, yPromise] ) // 当这个Promise被解析后，我们拿起收到的`X`和`Y`的值，并把它们相加 .then( function(values){ // `values`是一个从先前被解析的Promise那里收到的消息数组 return values[0] + values[1]; } );}// `fetchX()`和`fetchY()`分别为它们的值返回一个Promise，// 这些值可能在 *现在* 或 *稍后* 准备好add( fetchX(), fetchY() )// 为了将两个数字相加，我们得到一个Promise。// 现在我们链式地调用`then(..)`来等待返回的Promise被解析.then( function(sum){ console.log( sum ); // 这容易多了！} );","link":"/2016/09/11/Javascript-Promise/js-Promise-%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BE%8B%E5%AD%90/"},{"title":"js-Promise-解决地狱回调","text":"之前见过的一道Promise面试题的答案 123456789101112131415161718192021222324252627282930313233function red(){ console.log('red');}function green(){ console.log('green');}function yellow(){ console.log('yellow');}var tic = function(timmer, cb){ return new Promise(function(resolve, reject) { setTimeout(function() { cb(); resolve(); }, timmer); });};var d = new Promise(function(resolve, reject){resolve();});var step = function(def) { def.then(function(){ return tic(3000, red); }).then(function(){ return tic(2000, green); }).then(function(){ return tic(1000, yellow); }).then(function(){ step(def); });}step(d);","link":"/2016/09/11/Javascript-Promise/js-Promise-%E8%A7%A3%E5%86%B3%E5%9C%B0%E7%8B%B1%E5%9B%9E%E8%B0%83/"},{"title":"js-pattern--h-模板方法模式","text":"基于复用技术、抽象类--&gt;继承抽象类 创建抽象类12345678910111213141516171819202122232425262728var CaffeineBeverage = function () {};CaffeineBeverage.prototype.prepareRecipe = function () { this.boilWater(); this.brew(); this.pourOnCup(); if (this.customerWantsCondiments()) { // 如果可以想加小料，就加上 this.addCondiments(); }};CaffeineBeverage.prototype.boilWater = function () { console.log(&quot;将水烧开!&quot;);};CaffeineBeverage.prototype.pourOnCup = function () { console.log(&quot;将饮料到再杯子里!&quot;);};CaffeineBeverage.prototype.brew = function () { throw new Error(&quot;该方法必须重写!&quot;);};CaffeineBeverage.prototype.addCondiments = function () { throw new Error(&quot;该方法必须重写!&quot;);};// 默认加上小料CaffeineBeverage.prototype.customerWantsCondiments = function () { return true;}; 实现抽象类123456789101112131415161718192021222324252627282930// 冲咖啡var Coffee = function () { CaffeineBeverage.apply(this);};Coffee.prototype = new CaffeineBeverage();Coffee.prototype.brew = function () { console.log(&quot;从咖啡机想咖啡倒进去!&quot;);};Coffee.prototype.addCondiments = function () { console.log(&quot;添加糖和牛奶&quot;);};Coffee.prototype.customerWantsCondiments = function () { return confirm(&quot;你想添加糖和牛奶吗？&quot;);};//冲茶叶var Tea = function () { CaffeineBeverage.apply(this);};Tea.prototype = new CaffeineBeverage();Tea.prototype.brew = function () { console.log(&quot;泡茶叶!&quot;);};Tea.prototype.addCondiments = function () { console.log(&quot;添加柠檬!&quot;);};Tea.prototype.customerWantsCondiments = function () { return confirm(&quot;你想添加柠檬嘛？&quot;);};","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--h-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"js-pattern--h-策略模式","text":"策略比状态模式 少了一个储存状态的类1234567891011121314151617181920212223242526272829303132'use strict'let PriceStrategy = (function () { class strategy { constructor() { let that = this; this.change = { return30: () =&gt; { }, return50: (price) =&gt; { return price/2; }, percent90: () =&gt; { }, percent50: () =&gt; { } } } running(algorithm,price){ let _obj = new strategy(); return _obj.change[algorithm] &amp;&amp; _obj.change[algorithm](price) } } return new strategy().running;})();console.log(PriceStrategy('return50','3214.32'))","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--h-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"js-Promise","text":"12345678910111213var assert = require('power-assert');describe('Basic Test', function () { it(&quot;should use `done` for test?&quot;, function (done) { var promise = Promise.resolve(); promise.then(function (value) { assert(false); }).then(done, done); });}); 第二种写法 12345it(&quot;should be fail&quot;, function () { return Promise.resolve().then(function () { assert(false);// =&gt; 测试失败 });});","link":"/2016/09/11/Javascript-Promise/js-Promise/"},{"title":"js-pattern--h-观察者模式","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict';/** * 观察者模式:定义依赖的关系 */let Observer = (function () { //懒加载单例模式 let _instance = null; let _message = Symbol(&quot;message&quot;); class Observer { constructor() { //生成需要存储的字典 this[_message] = {}; } //注册信息接口,给需要注册的函数一个名字; regist(key, fn) { !!this[_message][key] ? this[_message][key].push(fn) : this[_message][key] = [fn]; } //发布信息接口,当触发函数名字的时候,提供对应的功能 fire(key, args) { if (!this[_message][key]) { return false; } let date = { key: key, args: args || {} }; for (let i = 0, len = this[_message][key].length; i &lt; len; i++) { this[_message][key][i].apply(null, date); } } //移除信息接口 remove(key, fn) { if (Array.isArray(this[_message][key])) { let i = this[_message][key].length - 1; for (; i &gt; 0; i--) { this[_message][key][i] === fn &amp;&amp; this[_message][key].splice(i, 1); } } } } return function () { return _instance = _instance || new Observer(); }})();module.exports = Observer(); 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445'use strict';const Obp = require('./design_pattern/observe');/** * 需要传递的东西 要建立在构造函数内,在创建的时候就应该初始化了,要不this得值很难传过去的 */class Student{ constructor (name){ let that = this; this._name = name; this.say = function () { console.log(that._name + &quot;正在回答&quot;); } } answer(question){ Obp.regist(question,this.say); } sleep(question){ console.log(this._name + &quot;正在睡觉&quot;) Obp.remove(question,this.say); }}class Teacher{ constructor(){ } ask(question){ Obp.fire(question); }}let one = new Student(&quot;学生1&quot;);let one2 = new Student(&quot;学生2&quot;);let one3 = new Student(&quot;学生3&quot;);one.answer(&quot;丽君是不是傻瓜&quot;);one2.answer(&quot;丽君是不是傻瓜&quot;);one3.answer(&quot;丽君是不是傻瓜&quot;);one3.sleep(&quot;丽君是不是傻瓜&quot;);let two = new Teacher();two.ask(&quot;丽君是不是傻瓜&quot;);","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--h-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"js-pattern--h-状态模式","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071'use strict';let State = (function () { class State { constructor() { /** * 状态类 * @type {{}} * @private */ let that = this; that._currState = {}; that.states = { jump: function () { console.log(&quot;jump&quot;) }, move: function () { console.log(&quot;move&quot;) }, shoot: function () { console.log(&quot;shoot&quot;) }, squat: function () { console.log(&quot;squat&quot;) } }; /** * 创建组合类之动作控制类 * @type {{change, goes}} */ let {change, goes} = (function () { class action { constructor() { this.change = function () { //参数转成数组 let arg = [].slice.call(arguments).sort(); that._currState = {}; if (arg.length) { for (var i in arg) { that._currState[arg[i]] = true; } } return that; } this.goes = function () { console.log(&quot;触发一次动作&quot;) for (var i in that._currState) { that.states[i] &amp;&amp; that.states[i]() } return that; } } } let _action = new action(); return { change: _action.change, goes: _action.goes } })(); this.change = change; this.goes = goes; } } return new State();})();console.log(State.change('jump', 'shoot').goes().goes().change(&quot;move&quot;).goes());","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--h-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"js-Promise-传值","text":"12345678910111213141516171819function doubleUp(value) { return value * 2;}function increment(value) { return value + 1;}function output(value) { console.log(value);// =&gt; (1 + 1) * 2}var promise = Promise.resolve(1);promise .then(increment) .then(doubleUp) .then(output) .catch(function(error){ // promise chain中出现异常的时候会被调用 console.error(error); });","link":"/2016/09/11/Javascript-Promise/js-Promise-%E4%BC%A0%E5%80%BC/"},{"title":"js-pattern--s-享元模式","text":"优化性能、生成大量相似的对象、 如页面翻页的时候,只保留结构模板,而替换中间的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869'use strict';/** * 享元元素 */let flyweightIphone = (function () { let _model = Symbol(&quot;model&quot;); let _screen = Symbol(&quot;screen&quot;); let _memory = Symbol(&quot;memory&quot;); class iphone { constructor(model, screen, memory) { this[_model] = model; this[_screen] = screen; this[_memory] = memory; } } return iphone;})();/** * 享元工厂 * @type {{get}} */let flyweightFactory = (function () { var iphones = {}; return { get: function (model, screen, memory) { const key = model + screen + memory; return iphones[key] || new flyweightIphone(model, screen, memory); } }})();/** * 享元类 */let iphone = (function () { let _SN = Symbol(&quot;SN&quot;); let _flyweight = Symbol(&quot;flyweight&quot;); class iphone { constructor(model, screen, memory, SN) { this[_flyweight] = flyweightFactory.get(model, screen, memory, SN); this[_SN] = SN; } } return iphone;})();/** * 享元测试 */let for_iphone = function () { var phones = []; for (var i = 0; i &lt; 100; i++) { let memory = i % 2 == 0 ? 16 : 32; phones.push(new iphone(&quot;iphone6s&quot;, 5.0, memory, i)); }}function cal_fn_time(fn) { var timebegin = (new Date()).getTime(); console.log(for_iphone); fn(); var timeend = (new Date()).getTime(); return (timeend - timebegin)/1000 + &quot;s&quot;;}console.log(cal_fn_time(for_iphone)); //享元元素 12345function IphoneFlyweight(model, screen, memory) { this.model = model; this.screen = screen; this.memory = memory;} //享元工厂,生成共享的对象;生成字典保存并获取享元对象 12345678910111213var flyweightFactory = (function () { var iphones = {}; return { get: function (model, screen, memory) { var key = model + screen + memory; if (!iphones[key]) { iphones[key] = new IphoneFlyweight(model, screen, memory); } return iphones[key]; } };})(); //关键在于除去了唯一的值之外,生成的共享元素并不多,可以直接获取 1234 function Iphone(model, screen, memory, SN) { this.flyweight = flyweightFactory.get(model, screen, memory); this.SN = SN;} //最终生成的数据 123456var phones = [];for (var i = 0; i &lt; 1000000; i++) { var memory = i % 2 == 0 ? 16 : 32; phones.push(new Iphone(&quot;iphone6s&quot;, 5.0, memory, i));}console.log(phones); 在DOM的应用是:事件委托也运用了享元模式的原理 123(&quot;.menu&quot;).on(&quot;click&quot;, &quot;.item&quot;, function () { console.log($(this).text());})","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--s-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"js-pattern--k-节流模式","text":"123456789101112131415161718192021222324_.throttle = function(func, wait) { var context, args, timeout, result; var previous = 0; var later = function() { previous = new Date; timeout = null; result = func.apply(context, args); }; return function() { var now = new Date; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0) { clearTimeout(timeout); timeout = null; previous = now; result = func.apply(context, args); } else if (!timeout) { timeout = setTimeout(later, remaining); } return result; }; }; 123456789101112131415_.debounce = function(func, wait, immediate) { var timeout, result; return function() { var context = this, args = arguments; var later = function() { timeout = null; if (!immediate) result = func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) result = func.apply(context, args); return result; };};","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern--k-%E8%8A%82%E6%B5%81%E6%A8%A1%E5%BC%8F/"},{"title":"js-pattern-简介与对象的收编","text":"参考并结合es6类 是JavaScript 设计模式 12345-a : 架构型设计模式-h : 行为型设计模式-i : 创建型设计模式-k : 技巧型设计模式-s : 结构型设计模式 高内聚 : =内聚力,是软件度量,组成模块程度,即包含鲁棒性(健壮性),可靠度,可复用性和易懂性; 耦合性 : 与内聚性相对; 全局函数的处理用对象收编12345678let obj = { one : ()=&gt;{ }, two : ()=&gt;{ }} 真假对象12345678910let obj = ()=&gt; { return { one: ()=&gt; { console.log(&quot;one&quot;) }, two: ()=&gt; { console.log(&quot;two&quot;) } }} 类的形式12345678910111213class obj { constructor() { } one(){ console.log(&quot;one&quot;); return this; } two(){ console.log(&quot;two&quot;) return this; }} 函数祖先绑定12345Function.prototype.addMethod = function(name,func){ this[name] = func; //类式调用方法 //this.prototype[name] = fn ;} 初始化12let methons = function(){};or let methons = new Function();","link":"/2016/09/11/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/js-pattern-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%94%B6%E7%BC%96/"},{"title":"jenkins-常用配置记录","text":"设定默认端口 123sudo defaults write /Library/Preferences/org.jenkins-ci httpPort 7070 启动 123sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist 关闭 123sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist","link":"/2016/09/11/jenkins/jenkins-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"nginx-开发理解","text":"安装 epel 123sudo yum install epel-release 安装 nginx 123sudo yum install nginx 启动 123sudo /etc/init.d/nginx start 查看 worker_process 数目 123grep ^processor /proc/cpuinfo | wc -l 启动 123nginx 重启 123sudo nginx -s reload 删除 123pkill nginx 安装依赖(默认目录)–&gt;http://nginx.org/en/download.html 1yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel 了解四个部分 1main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置） main 1影响所有的配置 server 1域名-IP-端口 upstream 1反向代理和负载均衡 location 1网页的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105-------------main# 查看配置文件是否正确sudo nginx -t# 查看默认的配置cat /usr/local/etc/nginx/nginx.conf.default# user 管理用户 用户组whoamigroups# worker_processes 占用内核的数量sysctl -n hw.ncpu# error_log 路径 模式mac 路径:/usr/local/var/log/nginx/error.logcentos 路径: /var/log/nginx/error.log模式类型 : debug/info/notice/warn/error/crit (越不详细)# pid 路径mac 路径:/usr/local/var/run/nginx.pidcentos 路径:/var/run/nginx.pid---------------main---------------events# worker_connections number若提示 worker_connections exceed open file resource limit: 256,可以在main的部分添加 worker_rlimit_nofile 2048;---------------events---------------httphttp { # 关闭错误页面的nginx版本数字，提高安全性 server_tokens off; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' # '$status $body_bytes_sent &quot;$http_referer&quot; ' # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #access_log logs/access.log main; #高效文件传输模式,是否调用sedfile函数输出文件,减少上下文切换,若下载等应用盘则off sendfile on; #tcp_nopush on; #长连接超时时间 keepalive_timeout 65; #send_timeout : 响应客户端超时的时间; #启动gzip,为了减少网路传输 gzip on; #允许压缩的页面的最小字节数,小于1k的可能越压越大 gzip_min_length 1k; #数据流 gzip_buffers 4 16k; #协议的版本,支持早期的不支持gzip的浏览器 gzip_http_version 1.0; #压缩比,越小越快,越大越耗能; gzip_comp_level 6; #压缩的类型 gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #响应头加上vary gzip_vary on; # http_proxy 设置 # 请求文件字节数的大小和缓存区 client_max_body_size 10m; client_body_buffer_size 128k; #proxy 时间控制 proxy_connect_timeout 75; proxy_send_timeout 75; proxy_read_timeout 75; #proxy 缓存设置 proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; #proxy 临时文件大小 proxy_temp_file_write_size 64k; # 确认路径三 centos的路径在 /etc/nginx/ proxy_temp_path /usr/local/etc/nginx/proxy_temp 1 2; # 引入其他的server include servers/*;}---------------http # 关闭错误页面的nginx版本数字，提高安全性 server_tokens off;","link":"/2016/09/11/nginx/nginx-%E5%BC%80%E5%8F%91%E7%90%86%E8%A7%A3/"},{"title":"mac-http-proxy","text":"==&gt; Pouring privoxy-3.0.24.el_capitan.bottle.1.tar.gz==&gt; CaveatsTo have launchd start privoxy now and restart at login: brew services start privoxyOr, if you don’t want/need a background service you can just run: privoxy /usr/local/etc/privoxy/config==&gt; Summary🍺 /usr/local/Cellar/privoxy/3.0.24: 51 files, 1.6M 启动 http代理 /usr/local/Cellar/privoxy/3.0.24/sbin/privoxy /usr/local/etc/privoxy/config 测试是否抵达地址curl –connect-timeout 2 -x 127.0.0.1:8118 http://www.baidu.com","link":"/2016/09/11/OSX/mac-http-proxy/"},{"title":"mac-切换root用户","text":"sudo -i","link":"/2016/09/11/OSX/mac-%E5%88%87%E6%8D%A2root%E7%94%A8%E6%88%B7/"},{"title":"alfred-workflows-多风格的编码变量-插件","text":"昨晚有空写了个 alfred workflows JS 版… https://github.com/xudaolong/CodeVar CodeVar开发基于 Javascript、 alfy、有道翻译api; 使用下载workflows文件并运行;接下来的版本会提供词根、其他变量风格进行更新;如果有时间的话…谢谢使用… 效果 小驼峰命名法:xt 大驼峰命名法:dt 下划线命名法:xh 常量命名法:cl","link":"/2016/09/11/OSX/alfred-workflows-%E5%A4%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BC%96%E7%A0%81%E5%8F%98%E9%87%8F-%E6%8F%92%E4%BB%B6---/"},{"title":"mac-日常遇到的命令记录","text":"mac 查看进程的端口号 ps aux | grep process_name mac 路径记录 12345brew 安装路径 : /usr/local/Cellar/;brew 软连接 : /usr/local/;mac 开机启动文档: ~/Library/LaunchAgents; mac 删除非空文件 1234sudo rm -rf node_modules/sudo rmdir -p node_modules/","link":"/2016/09/11/OSX/mac-%E6%97%A5%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"},{"title":"mac-切换到子用户","text":"su -l username","link":"/2016/09/11/OSX/mac-%E5%88%87%E6%8D%A2%E5%88%B0%E5%AD%90%E7%94%A8%E6%88%B7/"},{"title":"mac-系统文件夹的含义","text":"bin---------储存有基本的UNIX指令 sbin--------UNIX 系统指令的储存地方, 是比较进阶的指令 etc---------系统设定档桉储存地方 var---------改动频繁的档桉, 都置放于此, 例如各log档桉 tmp--------系统的暂存档 usr---------UNIX的使用者专用档桉夹","link":"/2016/09/11/OSX/mac-%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"brew-java-安装","text":"12345678brew updatebrew tap caskroom/caskbrew install brew-caskbrew cask info java7brew cask install java7","link":"/2016/09/11/OSX/brew-java-%E5%AE%89%E8%A3%85/"},{"title":"mac-终端-用-proxychains-ng-走-shadowsocks","text":"安装 proxychains-ng 1brew install proxychains-ng 配置 /usr/local/etc/proxychains.conf 1socks5 127.0.0.1 1080","link":"/2016/09/11/OSX/mac-%E7%BB%88%E7%AB%AF-%E7%94%A8-proxychains-ng-%E8%B5%B0-shadowsocks/"},{"title":"mongodb-开机启动","text":"brew services start mongodb","link":"/2016/09/11/OSX/mongodb-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"},{"title":"mac-访问-Windows-共享文件夹","text":"smb://Windows主机的IP地址","link":"/2016/09/11/OSX/mac-%E8%AE%BF%E9%97%AE-Windows-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"title":"brew-安装-mysql-启动","text":"出现的问题如下:ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 另外启动mysql brew services start mysql mysql.server {start|stop|restart|reload|force-reload|status}","link":"/2016/09/11/Mysql/brew-%E5%AE%89%E8%A3%85-mysql-%E5%90%AF%E5%8A%A8/"},{"title":"mongodb-remove","text":"db.集合名称.remove({query}, justOne)query：过滤条件，可选justOne：是否只删除查询到的第一条数据，值为true或者1时，只删除一条数据，默认为false，可选。 删除第一条 123456789&gt; db.student.remove({age:28}, true)WriteResult({ &quot;nRemoved&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;mongodb&quot;, &quot;java&quot; ] } 删除所有的数据 1234567&gt; db.student.remove({age:28})WriteResult({ &quot;nRemoved&quot; : 2 })&gt; db.student.find(){ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;mongodb&quot;, &quot;java&quot; ] } 删除集合所有{} 12&gt; db.student.remove({})WriteResult({ &quot;nRemoved&quot; : 4 })","link":"/2016/09/11/mongodb/mongodb-remove/"},{"title":"mongodb-insert&amp;save","text":"拥有两种方法一旦数据中包含_id,insert不插入相同的值,save则更新数据 123456789101112131415161718&gt; db.student.insert({&quot;_id&quot;: 1, &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;: 28})WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 28 }&gt; db.student.insert({&quot;_id&quot;: 1, &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;: 27})WriteResult({ &quot;nInserted&quot; : 0, &quot;writeError&quot; : { &quot;code&quot; : 11000, &quot;errmsg&quot; : &quot;E11000 duplicate key error collection: zyhdb.student index: _id_ dup key: { : 1.0 }&quot; }})&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 28 }&gt; db.student.save({&quot;_id&quot;: 1, &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;: 27})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27 } 批量插入 12345678910111213141516&gt; db.student.insert([{&quot;_id&quot;: 2, &quot;name&quot;: &quot;lisi&quot;},{&quot;_id&quot;: 3, &quot;name&quot;: &quot;wangwu&quot;}, {&quot;_id&quot;: 4, &quot;name&quot;: &quot;zhaoliu&quot;, &quot;age&quot;: 28}])BulkWriteResult({&quot;writeErrors&quot; : [ ],&quot;writeConcernErrors&quot; : [ ],&quot;nInserted&quot; : 3,&quot;nUpserted&quot; : 0,&quot;nMatched&quot; : 0,&quot;nModified&quot; : 0,&quot;nRemoved&quot; : 0,&quot;upserted&quot; : [ ]})&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot; }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot; }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 } 循环插入 12345678910111213&gt; for(var i=0; i&lt;10; i++){db.fortest.insert({num: i})}WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.fortest.find(){ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeabab5&quot;), &quot;num&quot; : 0 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeabab6&quot;), &quot;num&quot; : 1 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeabab7&quot;), &quot;num&quot; : 2 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeabab8&quot;), &quot;num&quot; : 3 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeabab9&quot;), &quot;num&quot; : 4 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeababa&quot;), &quot;num&quot; : 5 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeababb&quot;), &quot;num&quot; : 6 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeababc&quot;), &quot;num&quot; : 7 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeababd&quot;), &quot;num&quot; : 8 }{ &quot;_id&quot; : ObjectId(&quot;57469e80142cea1d9aeababe&quot;), &quot;num&quot; : 9 }","link":"/2016/09/11/mongodb/mongodb-insert&save/"},{"title":"mongodb-find&amp;sort","text":"查询指定的键 db.集合名称.find({查询条件},{指定键})指定键：1表示显示，0表示不显示，_id默认显示 123456789101112131415161718192021&gt; db.student.find({},{name:1}){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot; }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot; }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot; }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot; }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot; }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot; }&gt; db.student.find({},{_id:0, age:0}){ &quot;name&quot; : &quot;zhangsan&quot;, &quot;sex&quot; : 1 }{ &quot;name&quot; : &quot;lisi&quot; }{ &quot;name&quot; : &quot;wangwu&quot; }{ &quot;name&quot; : &quot;zhaoliu&quot; }{ &quot;name&quot; : &quot;qianliu&quot; }{ &quot;name&quot; : &quot;sunba&quot; }&gt; db.student.find({},{_id:0, name:1}){ &quot;name&quot; : &quot;zhangsan&quot; }{ &quot;name&quot; : &quot;lisi&quot; }{ &quot;name&quot; : &quot;wangwu&quot; }{ &quot;name&quot; : &quot;zhaoliu&quot; }{ &quot;name&quot; : &quot;qianliu&quot; }{ &quot;name&quot; : &quot;sunba&quot; } db.集合名称.findOne({查询条件},{指定键}) 查询出符合条件的第一条数据 1234567891011121314151617&gt; db.student.findOne(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }db.集合名称.find({查询条件},{指定键}).limit(数字)查询前几条数据&gt; db.student.find().limit(3){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }db.集合名称.find({查询条件},{指定键}).skip(数字)跳过前几条数据&gt; db.student.find().skip(2){ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : 7, &quot;age&quot; : 70 } 可以使用limit()和skip()实现分页 12345678910&gt; db.student.find().skip(0).limit(3){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }&gt; db.student.find().skip(3).limit(3){ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }&gt; db.student.find().skip(6).limit(3){ &quot;_id&quot; : 7, &quot;name&quot; : 7, &quot;age&quot; : 70 } db.集合名称.find().sort({键:数字})数字为1表示升序，数字为2表示降序 db.student.find().sort({age:1}) 12345678{ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 7, &quot;name&quot; : 7, &quot;age&quot; : 70 } db.student.find().sort({age:1, _id:-1}) 1234567{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 7, &quot;name&quot; : 7, &quot;age&quot; : 70 }","link":"/2016/09/11/mongodb/mongodb-find&sort/"},{"title":"mongodb-update","text":"db.集合名称.update({query},{update},upsert, multi})过滤条件;修改内容;是否插入数据(若不存在),默认false;是否只查询条件的第一条,默认false; 123456789&gt; db.student.update({_id:1}, {name:&quot;zhang&quot;})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhang&quot; }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } 更新/添加指定条件的某键;$set 123456789&gt; db.student.update({_id: 1},{$set:{name:&quot;zhangsan&quot;, age: 26}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } 删除指定条件的某键$unset 12345678910&gt; db.student.update({_id:7},{$unset:{age:1}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot; } 在原来的基础上的运算$inc 1234567891011&gt; db.student.update({_id:7}, {$inc:{age:-1}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;age&quot; : 31 } 数组 $push:当数据中不存在键时，创建数组类型的键并插入该值;如果存在该键，并且该键是数组类型时，则在此数&gt;组类型的数据上追加;如果存在该键，并且该键不是数组类型时，会报错。$pushAll:批量往数组中追加$addToSet:数组中有该值时不追加，没有该值时追加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; db.student.update({_id: 7},{$push:{skill:&quot;java&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;java&quot; ] }&gt; db.student.update({_id: 7},{$push:{skill:&quot;mongodb&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;java&quot;, &quot;mongodb&quot; ] }&gt; db.student.update({_id: 7},{$push:{name:&quot;111&quot;}})WriteResult({&quot;nMatched&quot; : 0,&quot;nUpserted&quot; : 0,&quot;nModified&quot; : 0,&quot;writeError&quot; : {&quot;code&quot; : 16837,&quot;errmsg&quot; : &quot;The field 'name' must be an array but is of type String in document {_id: 7.0}&quot;}})&gt; db.student.update({_id: 7},{$pushAll:{skill:[&quot;js&quot;,&quot;C++&quot;,&quot;java&quot;]}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;java&quot;, &quot;mongodb&quot;, &quot;js&quot;, &quot;C++&quot;, &quot;java&quot; ] }&gt; db.student.update({_id:7},{$addToSet:{skill:&quot;mongodb&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;java&quot;, &quot;mongodb&quot;, &quot;js&quot;, &quot;C++&quot;, &quot;java&quot; ] } $pop:删除数组的第一个或最后一个元素，值为-1时是删除第一个元素，值为1时是删除最后一个元素。$pull:删除数组中的某一个指定的数值$pullAll:删除数组中多个指定的数值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; db.student.update({_id:7},{$pop:{skill:1}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;java&quot;, &quot;mongodb&quot;, &quot;js&quot;, &quot;C++&quot; ] }&gt; db.student.update({_id:7},{$pop:{skill:-1}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;mongodb&quot;, &quot;js&quot;, &quot;C++&quot; ] }&gt; db.student.update({_id:7},{$pull:{skill:&quot;js&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;mongodb&quot;, &quot;C++&quot; ] }&gt; db.student.update({_id:7},{$pullAll:{skill:[&quot;js&quot;]}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ &quot;mongodb&quot;, &quot;C++&quot; ] }&gt; db.student.update({_id:7},{$pullAll:{skill:[&quot;mongodb&quot;,&quot;C++&quot;]}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }{ &quot;_id&quot; : 7, &quot;name&quot; : &quot;songjiu&quot;, &quot;skill&quot; : [ ] } id不能转换 123456789101112131415161718&gt; db.student.update({_id:1},{_id:0, name:&quot;zhangsanzhangsan&quot;})WriteResult({&quot;nMatched&quot; : 0,&quot;nUpserted&quot; : 0,&quot;nModified&quot; : 0,&quot;writeError&quot; : {&quot;code&quot; : 16837,&quot;errmsg&quot; : &quot;The _id field cannot be changed from {_id: 1.0} to {_id: 0.0}.&quot;}})&gt; db.student.find(){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 26 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }","link":"/2016/09/11/mongodb/mongodb-update/"},{"title":"mongodb-初识","text":"mongodb 基本命令 show dbs or db当前数据库 use dbs切换指定数据库,若进行过操纵则自动创建该数据库 show collections当前数据库的所有集合 db.stats()当前数据库的统计信息 db.getCollectionNames()当前数据库的集合名称列表 12345678910111213141516171819202122db.getCollection( db.getLogComponents( db.getQueryOptions( db.getSlaveOk(db.getCollectionInfos( db.getMongo( db.getReplicationInfo( db.getUser(db.getCollectionNames( db.getName( db.getRole( db.getUsers(db.getLastError( db.getPrevError( db.getRoles( db.getWriteConcern(db.getLastErrorCmd( db.getProfilingLevel( db.getSiblingDB(db.getLastErrorObj( db.getProfilingStatus( db.getSisterDB( db.createCollection()创建集合 db.mycoll.drop()删除集合 db.storeCollection.save()更新记录 db.storeCollection.findOne()查询一条记录 db.storeColletion.find()查询多条记录 db.sotreColletion.remove()删除记录 db.dropDatabase()删除当前的数据库,但上下文还是当前的 下面是其他删除的数据 1db.dropAllRoles( db.dropAllUsers( db.dropDatabase( db.dropRole( db.dropUser( db.serverStatus()当前服务器的状态,查看是否存在问题,便于修复 mongodb 符号&amp;查询 查询方式 12345$lt:&lt; $lte:&lt;= $gt:&gt; $gte:&gt;= $ne:!= 123456789&gt; db.student.find({age:{$lt:30}}){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }&gt; db.student.find({age:{$ne:27}}){ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } $in:包含$nin:不包含 123456789&gt; db.student.find({age:{$in:[27,28]}}){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }&gt; db.student.find({age:{$nin:[27,28]}}){ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } $or:或者 12345&gt; db.student.find({$or:[{age:{$lt:29}}, {name:&quot;sunba&quot;}]}){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } null:空值 123456&gt; db.student.find({sex: null}){ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 } $type:键是某种类型的double:1string:2… 123456789101112&gt; db.student.insert({_id:7, name:7, age:70})WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.student.find({name: {$type: 2}}){ &quot;_id&quot; : 1, &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 1 }{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;wangwu&quot;, &quot;age&quot; : 30 }{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;zhaoliu&quot;, &quot;age&quot; : 28 }{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;qianliu&quot;, &quot;age&quot; : 33 }{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;sunba&quot;, &quot;age&quot; : 32 }&gt; db.student.find({name: {$type: 1}}){ &quot;_id&quot; : 7, &quot;name&quot; : 7, &quot;age&quot; : 70 } 正则表达式 12&gt; db.student.find({name: /si\\b/}){ &quot;_id&quot; : 2, &quot;name&quot; : &quot;lisi&quot;, &quot;age&quot; : 27 }","link":"/2016/09/11/mongodb/mongodb-%E5%88%9D%E8%AF%86/"},{"title":"mongodb-索引","text":"db.page.ensureIndex()创建索引,升序:1,降序:-1 db.page.Indexes()查询索引 db.mycoll.dropIndex() or db.mycoll.dropIndexes()删除索引 db.page.reIndex()重建索引","link":"/2016/09/11/mongodb/mongodb-%E7%B4%A2%E5%BC%95/"},{"title":"rn-mac-android-开发环境部署","text":"参考资源 http://facebook.github.io/react-native/docs/getting-started.html#contenthttp://reactnative.cn/docs/0.37/getting-started.htmlhttp://blog.csdn.net/gz_jero/article/category/6223090 遇到的问题如下: adb command not found:adb命令存在platform-tools中; 解决:在.bash_profile 文件中配置如下. 12export ANDROID_HOME=~/Library/Android/sdkexport PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools 2.关于sdk的安装慢(使用shadowscoks),安装失败,建议直接使用sdk manager进行安装. 123android sdk 3.关于选取sdk,选择 可解决问题:No system images installed for this target 1If you see &quot;No system images installed for this target.&quot; under CPU/ABI, go back to your &quot;SDK Manager&quot; and click on &quot;Show Package Details&quot; under &quot;SDK Platforms&quot;. You will then be able to install any missing system images, such as &quot;Google APIs Intel Atom (x86)&quot;.","link":"/2016/09/11/react-native/rn-mac-android-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"title":"rn-mac-android-开发日常记录","text":"react-native 调试参考 http://blog.csdn.net/quanqinyang/article/details/52215652 知识点 1.React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。 12345&lt;View&gt; &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt; &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt; &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}}/&gt;&lt;/View&gt; 2.使用flex: 1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex: 1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）默认: 横向并列 12345&lt;View style={{flex: 1}}&gt; &lt;View style={{flex: 1, backgroundColor: 'powderblue'}}/&gt; &lt;View style={{flex: 2, backgroundColor: 'skyblue'}}/&gt; &lt;View style={{flex: 3, backgroundColor: 'steelblue'}}/&gt;&lt;/View&gt; 3.关于FlexboxflexDirection、alignItems和justifyContent:React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex - start，以及flex只能指定一个数字值。 具体的样式列表:http://reactnative.cn/docs/0.37/layout-props.html 双数据的绑定:主要解决的是该变量增加和删除带来的重复地对相关组件的渲染的影响. 关于TextInput: onChangeText、onSubmitEditing、onSubmitEditing…更多查看:http://reactnative.cn/docs/0.37/textinput.html android 模拟器 获取不了网络/没有wifi 12adb shellgetprop 然后发现:模拟器的DNS地址 进行设置:在模拟器的Setting-&gt;无线网络设置里，把“启用数据流量”勾选上，让模拟器的TopTar上出现3G图标,另外在重启模拟器后设置的property会丢失，就需要重新设置一遍，可以使用下面的方法解决： 找到你的SDK目录，里面有个system-images文件夹，这里保存着系统镜像文件，用文本编辑器打开里面的build.prop文件，在里面加上net.dns1=DNS 1/Users/macbook/Library/Android/sdk/system-images/android-23/google_apis/x86","link":"/2016/09/11/react-native/rn-mac-android-%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[],"categories":[{"name":"ios","slug":"ios","link":"/categories/ios/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"vps","slug":"vps","link":"/categories/vps/"},{"name":"angular","slug":"angular","link":"/categories/angular/"},{"name":"apache-common","slug":"apache-common","link":"/categories/apache-common/"},{"name":"java","slug":"apache-common/java","link":"/categories/apache-common/java/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"express","slug":"express","link":"/categories/express/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"intellj-idea","slug":"intellj-idea","link":"/categories/intellj-idea/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"jenkins","slug":"jenkins","link":"/categories/jenkins/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"osx","slug":"osx","link":"/categories/osx/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"mongodb","slug":"mongodb","link":"/categories/mongodb/"},{"name":"react-native","slug":"react-native","link":"/categories/react-native/"}],"pages":[{"title":"","text":"Hi 👋 My name is DaoLong XuFull Stack Developer 🌍 I’m based in Guangzhou, China 🖥️ See my portfolio at DaoLong XU Official Website ✉️ You can contact me at xudaolong@gmail.com 🚀 I’m currently working on Shopline, JOYY 🧠 I’m learning includes more than just golang, typescript and other related. 🤝 I’m open to collaborating on chrome extension/electron/golang/website… Skills Socials BadgesMy GitHub Stats Support Me","link":"/about.html"}]}