{"posts":[{"title":"React hooks 入门和进阶","text":"React hooks可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性,它的出现提供了一种新型可复用组件间状态逻辑的途径,替换以往采用的HOC和Render Props的形式. 新增该特性的原由: https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation 🐶 特性 多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。 Hooks 可以引用其他 Hooks。 更容易将组件的 UI 与状态分离。 – 精读《React Hooks》 React hooks带来了更强的组合设计模式, 与状态的隔离更加清晰. 🐷生命周期React hooks的生命周期 React class component的生命周期 相比class component, 仅缺少对于不常见的 getSnapshotBeforeUpdate 和 componentDidCatch, 其他的阶段都有对应等价关系. 👍 React hooks1. 使用useState1const [state, setState] = useState(initialState); 1.1 initialState仅初次渲染起作用,往后的渲染被忽略 若initialState是一个函数, 则在初始渲染时调用并返回结果 1.2 state此时state等价于initialState 1.3 setState提供给更新state使用的函数。 因为setState是不可变的, 故可在使用useEffect和useCallback依赖列表中省略setState其与class中的setState方法不同, 不能自动合并更新对象 1234setState(prevState =&gt; { // 也可以使用 Object.assign return {...prevState, ...updatedValues};}); 2. 使用useEffectuseEffect相似等价于componentDidMount, componentDidUpdate , componentWillUnmount, 以下展示三个场景 2.1 每次渲染123React.useEffect( () =&gt; { Console.log(&quot;useEffect runs&quot;);}); 2.2 仅当依赖改变时渲染123React.useEffect( () =&gt; { Console.log(&quot;useEffect runs&quot;);}, [state]); 2.3 组件销毁时12345678useEffect(() =&gt; { console.log('mounted'); const subscription = props.source.subscribe(); return () =&gt; { console.log('unmounting...'); subscription.unsubscribe(); }}, []) // [] 空数组代表此effect仅在 mounted 和 unmounting 调用一次 建议使用 eslint-plugin-react-hooks 和 exhaustive-deps 配合使用 但useEffect又与componentDidMount、componentDidUpdate不同, 如下图所示, useEffect是在browser paints screen更新后进行延迟处理操作的。 但不是所有的effect都需要延迟, 像处理dom等操作时, 应该在browser paints screen前就要处理完成, 这时就需要使用 useLayoutEffects, 否则就会产生视觉的突兀感, 反正记着优先使用useEffect, 若处理中遇到异常则使用 useLayoutEffect, 见下面. 3. 使用useContextuseContext(MyContext) 等价于 class 中的 static contextType = MyContext 或 &lt;MyContext.Consumer&gt; 12345678910111213141516171819202122import React, { useContext } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;const Context = React.createContext();function Display() { const value = useContext(Context); return &lt;div&gt;{value}, I am your Father.&lt;/div&gt;;}function App() { return ( &lt;Context.Provider value={&quot;Luke&quot;}&gt; &lt;Display /&gt; &lt;/Context.Provider&gt; );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 4. 使用useReduceruseState的加强版, 可代替去处理复杂深层结构的state, 本质就是使用 dispatch 替换 callback 局部状态不推荐使用 useReducer , 会导致函数内部更复杂, 难以阅读, 在多组件通信时可结合 useContext一起使用 1234567891011121314151617181920212223const initialState = {count: 0};function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; );} 4.1 initialState此时state等价于initialState 惰性初始化 12345function init(initialState) { return {count: initialState};}const [state, dispatch] = useReducer(reducer, initialState, init); 5. 使用useCallbackuseCallback(fn, deps) 等价于 useMemo(() =&gt; fn, deps), 初始化后会fn会仅当deps发生变化时重新渲染, 主要用作缓存函数 123456const memoizedCallback = useCallback( () =&gt; { doSomething(a, b); }, [a, b],); 6. 使用useMemouseMemo会在渲染时运行callback并赋值, 主要用作缓存复杂的函数的结果值 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 7. 使用useRefuseRef是一种主要用来访问Dom的方式, 无论节点如何变化, 其属性current仍指向dom节点 1const refContainer = useRef(initialValue); 7.1 initialValue此时initialValue 等价于refContainer.current 7.2 refContainerrefContainer是一个mutable的ref object, 其在整个component生命周期内保持不变 8. 使用useImperativeHandleuseImperativeHandle 主要用来暴露本身component的自定义属性给父级component使用 该例子展示可以在父级组件中调用子组件暴露的方法和对象: 12345678910111213141516171819202122232425262728293031323334353637import React, { useRef, useEffect, useImperativeHandle, forwardRef} from &quot;react&quot;;import { render } from &quot;react-dom&quot;;const ChildInput = forwardRef((props, ref) =&gt; { const inputRef = useRef(null); useImperativeHandle(ref, () =&gt; ({ ref: inputRef.current, doSomething: console.log })); return &lt;input type=&quot;text&quot; name=&quot;child input&quot; ref={inputRef} /&gt;;});function App() { const inputRef = useRef(null); useEffect(() =&gt; { inputRef.current.ref.focus(); inputRef.current.doSomething(&quot;打印&quot;); }, []); return ( &lt;div&gt; &lt;ChildInput ref={inputRef} /&gt; &lt;/div&gt; );}const rootElement = document.getElementById(&quot;root&quot;);render(&lt;App /&gt;, rootElement); 9. 使用useLayoutEffectuseLayoutEffect是一种用于在浏览器绘制前同步渲染页面的方案 该例子如果使用useEffect代替useLayoutEffect则会出现节点闪烁的情况: 1234567891011121314151617181920212223242526272829303132333435363738394041import React, { useState, useLayoutEffect, useRef } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;const LayoutEffectComponent = () =&gt; { const [width, setWidth] = useState(0); const [height, setHeight] = useState(0); const el = useRef(); useLayoutEffect(() =&gt; { console.log(&quot;el.current&quot;, el.current.clientWidth); setWidth(el.current.clientWidth); setHeight(el.current.clientHeight); }); return ( &lt;div&gt; &lt;h1&gt;useLayoutEffect Example&lt;/h1&gt; &lt;h2&gt;textarea width: {width}px&lt;/h2&gt; &lt;h2&gt;textarea height: {height}px&lt;/h2&gt; &lt;textarea onClick={() =&gt; { setWidth(0); }} ref={el} /&gt; &lt;/div&gt; );};function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;LayoutEffectComponent /&gt; &lt;/div&gt; );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 10. 使用useDebugValueuseDebugValue 用来在react devTools中显示自定义的hook标签 1useDebugValue(value) 🦄 实践例子下面展示一个用react hooks构建todo列表的demo: 1. 组件App.js 组件也可以写成自定义模式useInputForm.js 2. 逻辑抽离相关逻辑为了更好的维护和复用, 状态与 UI 的界限会越来越清晰useTodo.js 另相关代码已同步与Gist, 使用CodeExpander即可生成以上代码图片. 🐲FAQ1. 可以在函数内直接声明常量或普通函数吗?不可以, 考虑每次渲染会重新执行, 推荐放到函数组件外层避免性能问题或使用 useCallback 声明. 👻常用库react-use (持续更新…)","link":"/posts/426078165.html"},{"title":"基于Plasmo构建现代浏览器插件","text":"什么是 Chrome extension Background Scripts Content Scripts Popup、Options Pages Devtools Pages、New Tab Page、Sandbox Pages The Extension Manifest Understanding the Implications of Manifest v3 Extension and Browser APIs &amp;&amp; Permissions … 什么是 Plasmo Example Chrome Extension Plasmo 简化了构建浏览器扩展的过程，让您可以专注于实现逻辑。告别慢速迭代，迎接更好的开发体验 创建1pnpm create plasmo 开发与打包1234567...&quot;scripts&quot;: { &quot;dev&quot;: &quot;plasmo dev&quot;, &quot;build&quot;: &quot;plasmo build&quot;, &quot;zip&quot;: &quot;plasmo build --zip&quot;}... 支持 React/Svelte/Vue + Typescript Live-reloading + React HMR Storage API &amp; Messaging API 支持 .env* 环境变量 远程代码打包 (e.g., for Google Analytics) 支持打包跨浏览器插件，抹平manifest.json之间差异 包括 Firefox, Edge, Brave, Opera, Safari(即将)。 使用BPP进行自动发布 项目实践：麻雀Chrome插件麻雀是一款基于chrome extensions Manifest V3来构建简单易用的录屏诊断工具。 安装与配置chrome 应用商店下载地址 整体框架是怎么样的？ 项目结构又是怎么样的？12345678910111213141516171819202122232425262728293031.├── README.md├── assets│ ├── _locales ---------------------------【多语言】│ ├── ...│ └── icon512.png├── package.json├── pnpm-lock.yaml├── postcss.config.js├── src│ ├── background -------------------------【Background Scripts】│ ├── components│ ├── contents ---------------------------【Content Scripts】│ │ ├── camera.tsx│ │ ├── countdown.tsx│ │ ├── plugins.tsx│ │ ├── root.tsx│ │ └── toolbars.tsx│ ├── global.d.ts│ ├── hooks│ ├── img│ ├── options.tsx ------------------------【Options Pages】│ ├── popup.tsx --------------------------【Options Pages】│ ├── sandboxes --------------------------【Sandbox Pages】│ │ └── message.ts│ ├── styles│ ├── typings│ ├── utils│ └── webext├── tailwind.config.js└── tsconfig.json 技术栈：React(UI) + Tailwind(CSS) + Recoil(State) + Typescript 录屏的流程是怎么样的？ getUserMedia 输入源可以是物理设备，例如麦克风，网络摄像头或来自用户硬盘驱动器或远程网络对等体的本地或远程文件, 麦克风可以仅发射音频流，网络摄像机可以产生比其他视频流更高分辨率的视频流。 MediaStream对象表示实时媒体流，并允许应用程序代码获取数据，操纵单个轨道和指定输出。所有音频和视频处理（例如噪声消除，均衡，图像增强等）都由音频和视频引擎自动处理。 AudioContext 将麦克风音频与网页音频需要一个音频上下文(audio context)， 然后有一个音频数据的输入(input/source)，再加上处理程序(process)，然后是音频的输出(destination)，最后把他们连起来(connection) 如何实现 SPARROW 录屏功能？ 录屏功能 - 摄像头相关代码useMediaDevices1const devices = await navigator.mediaDevices.enumerateDevices() useCamera12345678910navigator.mediaDevices .getUserMedia(constraints) .then((stream) =&gt; { if (videoRef.current) { videoRef.current.srcObject = stream } }) .catch((error) =&gt; { logger.error(&quot;【摄像头】获取失败&quot;, error) }) 录屏功能 - 屏幕录制相关代码useRecord1234567891011121314151617181920212223&lt;!-- 获取 麦克风 --&gt;await navigator.mediaDevices.getUserMedia({ audio: { deviceId } })&lt;!-- 加载 MediaStream --&gt;const mediaStream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: videoConfig })const audioCtx = useRef(new AudioContext())audioCtx.current.createMediaStreamSource(mediaStream)&lt;!-- 加载 MediaRecorder --&gt;mediaStream.current = new MediaStream()mediaRecorder.current = new MediaRecorder( mediaStream.current, mediaConstraints.current)&lt;!-- 当倒计时结束时 --&gt;mediaRecorder.current?.start(1000)&lt;!-- 当结束录制 --&gt;mediaRecorder.current?.stop() 日志捕获方案选择？ 额外分享：「走一走」、「橡皮鸭」、「仔细阅读错误信息」、「阅读文档」、「Googling/StackOverflow/ISSUE/FAQ 的第一页」、「日志和堆栈」 整体流程 Chrome Devtools? 脚本注入方式：console, xhr/fetch? Chrome Debugger 方案 日志捕获功能 - 流程图 SPARROW 日志捕获功能 - 注册协议DevTools Protocol1234567891011121314151617181920class Debugger { ... start () { chrome.debugger.onDetach.addListener(this.onDetach) chrome.debugger.onEvent.addListener(this.onEvent) chrome.debugger.attach(this.debuggee, &quot;1.3&quot;, () =&gt; { &lt;!-- 监听网络相关 --&gt; chrome.debugger.sendCommand(this.debuggee, &quot;Network.enable&quot;, {}, () =&gt; { // 禁止使用缓存 chrome.debugger.sendCommand(this.debuggee, &quot;Network.setCacheDisabled&quot;, { cacheDisabled: true }) }) chrome.debugger.sendCommand(this.debuggee, &quot;Page.enable&quot;, {}) &lt;!-- 监听控制台相关 --&gt; chrome.debugger.sendCommand(this.debuggee, &quot;Runtime.enable&quot;, {}) }) } ... } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private onEvent = async ( source: chrome.debugger.Debuggee, method: string, params?: Object ) =&gt; { ... switch (method) { // 获取控制台信息 case &quot;Runtime.consoleAPICalled&quot;: this.logEntries.push(params as LogEntry) break case &quot;Runtime.exceptionRevoked&quot;: case &quot;Runtime.exceptionThrown&quot;: this.exceptions.push(params as ExceptionThrownParams) break // 获取网络状态 case &quot;Network.responseReceived&quot;: const responseReceivedParams = params as IResponseReceivedParams this.harEvents.push({ method, params: responseReceivedParams }) break case &quot;Network.loadingFailed&quot;: const loadingFailed = params as ILoadingFailed this.requestFail.set(loadingFailed.requestId, loadingFailed.errorText) this.harEvents.push({ method, params }) break // 如果请求最终从缓存中加载，则启动 case &quot;Network.requestServedFromCache&quot;: const requestServedFromCacheParams = params as IRequestServedFromCache this.harEvents.push({ method, params }) break // 当页即将发送 HTTP 请求时触发 case &quot;Network.requestWillBeSent&quot;: const requestWillBeSentParams = params as IRequestWillBeSent this.requestWillBeSend.set( requestWillBeSentParams.requestId, requestWillBeSentParams ) this.harEvents.push({ method, params }) break // 当 HTTP 请求加载完成时触发 case &quot;Network.loadingFinished&quot;: const loadingFinishedParams = params as INetworkLoadingFinishedParams const loadingFinishedParamsResp = await this.getResponseBody({ requestId: loadingFinishedParams.requestId, resourceType: loadingFinishedParams.type }) if (loadingFinishedParamsResp) { // 存储请求信息 this.requestHasResp.set(loadingFinishedParams.requestId, { body: loadingFinishedParamsResp.body, base64Encoded: loadingFinishedParamsResp.base64Encoded }) } this.harEvents.push({ method, params }) break // 其余的封装在 harEvents 中 default: this.harEvents.push({ method, params }) break } ... }","link":"/posts/796073919.html"}],"tags":[{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react hooks","slug":"react-hooks","link":"/tags/react-hooks/"},{"name":"chrome-extension","slug":"chrome-extension","link":"/tags/chrome-extension/"},{"name":"plasmo","slug":"plasmo","link":"/tags/plasmo/"}],"categories":[{"name":"react","slug":"react","link":"/categories/react/"},{"name":"chrome","slug":"chrome","link":"/categories/chrome/"}],"pages":[{"title":"","text":"Hi 👋 My name is DaoLong XuFull Stack Developer 🌍 I’m based in Guangzhou, China 🖥️ See my portfolio at DaoLong XU Official Website ✉️ You can contact me at xudaolong@gmail.com 🚀 I’m currently working on Shopline, JOYY 🧠 I’m learning includes more than just golang, typescript and other related. 🤝 I’m open to collaborating on chrome extension/electron/golang/website… Skills Socials BadgesMy GitHub Stats Support Me","link":"/about.html"}]}